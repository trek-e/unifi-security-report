---
phase: 13-websocket-support
plan: 04
type: execute
wave: 3
depends_on: ["13-03"]
files_modified:
  - src/unifi_scanner/logs/collector.py
  - src/unifi_scanner/api/client.py
autonomous: true

must_haves:
  truths:
    - "Collector fallback chain tries WS first, then REST, then SSH"
    - "REST client exposes cookies for WebSocket authentication"
    - "WS unavailable gracefully falls back to REST-only mode"
  artifacts:
    - path: "src/unifi_scanner/logs/collector.py"
      provides: "Updated fallback chain with WS support"
      contains: "WSLogCollector"
    - path: "src/unifi_scanner/api/client.py"
      provides: "Cookie extraction method"
      contains: "get_session_cookies"
  key_links:
    - from: "src/unifi_scanner/logs/collector.py"
      to: "src/unifi_scanner/logs/ws_collector.py"
      via: "WSLogCollector instantiation"
      pattern: "WSLogCollector"
    - from: "src/unifi_scanner/logs/collector.py"
      to: "src/unifi_scanner/api/client.py"
      via: "get_session_cookies call"
      pattern: "get_session_cookies"
---

<objective>
Integrate WebSocket collection into the existing fallback chain.

Purpose: The LogCollector currently has a fallback chain of API -> SSH. We need to add
WebSocket as the first option for WiFi events, with graceful fallback to REST when
WebSocket is unavailable (for older UniFi versions or network issues).

Output:
- Updated LogCollector with WS -> REST -> SSH fallback chain
- Cookie extraction method on UnifiClient for WebSocket auth
- Graceful fallback behavior when WebSocket unavailable
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-websocket-support/13-RESEARCH.md
@.planning/phases/13-websocket-support/13-03-SUMMARY.md

# Files to modify
@src/unifi_scanner/logs/collector.py
@src/unifi_scanner/api/client.py

# Files to reference
@src/unifi_scanner/logs/ws_collector.py
@src/unifi_scanner/api/ws_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cookie extraction to UnifiClient</name>
  <files>src/unifi_scanner/api/client.py</files>
  <action>
Add a method to UnifiClient for extracting session cookies needed by WebSocket:

**get_session_cookies() -> dict[str, str]:**
- Returns dictionary of cookie name -> value from the httpx client
- Format: {cookie.name: cookie.value for cookie in self._client.cookies.jar}
- Returns empty dict if not connected
- Used by WebSocket to reuse REST authentication

This method enables the WebSocket client to authenticate using the same session as
the REST client, without requiring separate login.

Add docstring explaining:
- Returns cookies from authenticated REST session
- Used for WebSocket authentication
- Empty dict if not connected
  </action>
  <verify>
```bash
python -c "from unifi_scanner.api import UnifiClient; print(hasattr(UnifiClient, 'get_session_cookies'))"
mypy src/unifi_scanner/api/client.py --ignore-missing-imports
```
  </verify>
  <done>
UnifiClient has get_session_cookies() method that returns dict[str, str].
Method extracts cookies from httpx client for WebSocket auth.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update LogCollector with WebSocket fallback chain</name>
  <files>src/unifi_scanner/logs/collector.py</files>
  <action>
Update LogCollector to support WebSocket as primary source for WiFi events:

**Add to constructor:**
- ws_manager: Optional[WebSocketManager] = None parameter
- Store reference for use in collect()

**Update collect() method:**
Add WebSocket collection step before API collection:

1. **Try WebSocket first** (if ws_manager provided and running):
   - Create WSLogCollector with manager and since_timestamp
   - Call ws_collector.collect()
   - If events received, log "websocket_events_collected" with count
   - Store events (they supplement API events, not replace)
   - Catch WSCollectionError and log warning, continue to REST

2. **Try REST API** (existing logic):
   - APILogCollector.collect() as before
   - If WS events were collected, merge with API events
   - Deduplicate by (timestamp, message) tuple

3. **Try SSH fallback** (existing logic):
   - If API failed/insufficient and SSH enabled
   - Merge and deduplicate as before

**Fallback behavior (WS-04 requirement):**
- WS unavailable (manager is None) -> skip WS, try REST
- WS connected but no events -> continue (events may arrive later)
- WS throws error -> log warning, fall back to REST
- REST unavailable too -> try SSH
- All fail -> LogCollectionError

**Logging:**
- Log which sources contributed to final result
- Example: "log_collection_complete", source="ws+api", ws_events=15, api_events=42

Update imports to include WSLogCollector, WSCollectionError, WebSocketManager.
  </action>
  <verify>
```bash
python -c "from unifi_scanner.logs import LogCollector; import inspect; sig = inspect.signature(LogCollector.__init__); print('ws_manager' in sig.parameters)"
mypy src/unifi_scanner/logs/collector.py --ignore-missing-imports
ruff check src/unifi_scanner/logs/collector.py
```
  </verify>
  <done>
LogCollector accepts optional ws_manager parameter.
collect() tries WS first, then REST, then SSH.
Events from WS and REST are merged and deduplicated.
WS failures gracefully fall back to REST-only mode.
  </done>
</task>

</tasks>

<verification>
1. UnifiClient.get_session_cookies() exists and returns dict
2. LogCollector accepts ws_manager parameter
3. `mypy src/unifi_scanner/api/client.py src/unifi_scanner/logs/collector.py --ignore-missing-imports` passes
4. `ruff check src/unifi_scanner/api/ src/unifi_scanner/logs/` passes
5. `pytest tests/ -v` - existing tests still pass
</verification>

<success_criteria>
- UnifiClient exposes cookies for WebSocket auth
- LogCollector has updated fallback chain: WS -> REST -> SSH
- WebSocket events merge with REST events correctly
- WS unavailable gracefully falls back to REST
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/13-websocket-support/13-04-SUMMARY.md`
</output>
