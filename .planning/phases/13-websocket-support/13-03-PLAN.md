---
phase: 13-websocket-support
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - src/unifi_scanner/api/ws_manager.py
  - src/unifi_scanner/api/__init__.py
  - src/unifi_scanner/logs/ws_collector.py
  - src/unifi_scanner/logs/__init__.py
autonomous: true

must_haves:
  truths:
    - "WebSocket manager runs in background thread alongside sync scheduler"
    - "WebSocket events are accessible from sync context via drain_events()"
    - "WS collector converts buffered events to LogEntry format"
  artifacts:
    - path: "src/unifi_scanner/api/ws_manager.py"
      provides: "WebSocketManager for background thread"
      exports: ["WebSocketManager"]
      min_lines: 60
    - path: "src/unifi_scanner/logs/ws_collector.py"
      provides: "WebSocket event collector"
      exports: ["WSLogCollector", "WSCollectionError"]
      min_lines: 40
  key_links:
    - from: "src/unifi_scanner/api/ws_manager.py"
      to: "src/unifi_scanner/api/websocket.py"
      via: "UnifiWebSocketClient instantiation"
      pattern: "UnifiWebSocketClient"
    - from: "src/unifi_scanner/api/ws_manager.py"
      to: "UnifiWebSocketClient.listen"
      via: "_on_event callback passed to listen()"
      pattern: "listen.*_on_event|_on_event.*listen"
    - from: "src/unifi_scanner/logs/ws_collector.py"
      to: "src/unifi_scanner/api/ws_manager.py"
      via: "drain_events call"
      pattern: "drain_events"
---

<objective>
Create the WebSocket manager for background operation and the WebSocket log collector.

Purpose: The existing scheduler uses APScheduler's BlockingScheduler (synchronous). The
WebSocket client is async. We need a bridge that runs WebSocket in a background thread
with its own event loop, while providing sync-friendly methods for the collector to
retrieve buffered events.

Output:
- WebSocketManager class that runs WebSocket in background thread
- WSLogCollector class that converts WebSocket events to LogEntry format
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-websocket-support/13-RESEARCH.md
@.planning/phases/13-websocket-support/13-01-SUMMARY.md

# Integration points
@src/unifi_scanner/api/websocket.py
@src/unifi_scanner/api/client.py
@src/unifi_scanner/logs/api_collector.py
@src/unifi_scanner/models/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocketManager for background thread</name>
  <files>src/unifi_scanner/api/ws_manager.py, src/unifi_scanner/api/__init__.py</files>
  <action>
Create src/unifi_scanner/api/ws_manager.py with:

**WebSocketManager class:**
- Manages WebSocket client in a daemon background thread
- Constructor takes no args (lazy initialization)
- _thread: Optional[threading.Thread] - the background thread
- _loop: Optional[asyncio.AbstractEventLoop] - event loop for async WebSocket
- _client: Optional[UnifiWebSocketClient] - the WebSocket client
- _buffer: WebSocketEventBuffer - shared buffer for events
- _running: bool - flag to control shutdown

**Methods:**
1. start(base_url: str, site: str, cookies: dict, device_type: DeviceType, verify_ssl: bool = False) -> None:
   - Creates UnifiWebSocketClient with provided parameters
   - Creates background thread running _run_loop()
   - Thread is daemon=True so it doesn't block shutdown
   - Logs "websocket_manager_started"

2. _on_event(event: BufferedEvent) -> None:
   - Callback passed to client.listen()
   - Parses incoming WebSocket message using parse_unifi_event()
   - If event is not None (is a WiFi event), adds to _buffer
   - This callback is how WebSocket events flow into the buffer

3. _run_loop() -> None:
   - Creates new event loop for this thread: asyncio.new_event_loop()
   - Sets it as the current loop: asyncio.set_event_loop(loop)
   - Calls client.connect() to establish connection
   - Then calls client.listen(self._on_event) in async loop to receive events
   - The listen() method runs indefinitely until stop() is called
   - Catches exceptions and logs them

4. drain_events() -> list[BufferedEvent]:
   - Called from sync context (main thread)
   - Calls _buffer.drain() directly (buffer uses threading.Lock, is thread-safe)
   - Returns list of buffered events
   - If not running, returns empty list

5. stop() -> None:
   - Sets _running = False
   - Schedules client.stop() in background loop
   - Waits for thread to join (with timeout)
   - Logs "websocket_manager_stopped"

6. is_running() -> bool:
   - Returns True if thread is alive and client is connected

Update src/unifi_scanner/api/__init__.py to export WebSocketManager.

Use structlog for all logging.
  </action>
  <verify>
```bash
python -c "from unifi_scanner.api import WebSocketManager; print('Import OK')"
mypy src/unifi_scanner/api/ws_manager.py --ignore-missing-imports
ruff check src/unifi_scanner/api/ws_manager.py
```
  </verify>
  <done>
WebSocketManager class exists with start(), _on_event(), drain_events(), stop(), is_running() methods.
_on_event callback is created and passed to client.listen() in _run_loop().
Class is exported from unifi_scanner.api module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WSLogCollector</name>
  <files>src/unifi_scanner/logs/ws_collector.py, src/unifi_scanner/logs/__init__.py</files>
  <action>
Create src/unifi_scanner/logs/ws_collector.py with:

**WSCollectionError exception:**
- Inherits from Exception
- Simple error for WebSocket collection failures

**WSLogCollector class:**
- Converts WebSocket buffered events to LogEntry format
- Constructor takes: manager (WebSocketManager), since_timestamp (Optional[datetime])
- Stores references for collect() to use

**collect() method:**
1. Call manager.drain_events() to get buffered events
2. Filter by since_timestamp if provided (apply 5-minute clock skew tolerance)
3. Convert each BufferedEvent to LogEntry:
   - Map event_type to appropriate LogEntry fields:
     - wu.connected -> source="WIRELESS", level="INFO"
     - wu.disconnected -> source="WIRELESS", level="INFO"
     - wu.roam -> source="WIRELESS", level="INFO"
     - wu.roam_radio -> source="WIRELESS", level="INFO"
     - sta:sync -> source="WIRELESS", level="DEBUG"
   - Extract message from event data (format: "{event_type}: {mac}")
   - Use BufferedEvent.timestamp for LogEntry.timestamp
   - Store raw data in LogEntry.raw_data if that field exists, otherwise in metadata
4. Return list of LogEntry objects
5. Log count of events collected

**Event type to message mapping:**
- wu.connected: "Client {mac} connected to {ap}"
- wu.disconnected: "Client {mac} disconnected from {ap}"
- wu.roam: "Client {mac} roamed from {ap} to {ap_to}"
- wu.roam_radio: "Client {mac} switched radio on {ap}"
- sta:sync: "Client {mac} state sync"

Use the existing LogEntry model from unifi_scanner.models.

Update src/unifi_scanner/logs/__init__.py to export WSLogCollector, WSCollectionError.
  </action>
  <verify>
```bash
python -c "from unifi_scanner.logs import WSLogCollector, WSCollectionError; print('Import OK')"
mypy src/unifi_scanner/logs/ws_collector.py --ignore-missing-imports
ruff check src/unifi_scanner/logs/ws_collector.py
```
  </verify>
  <done>
WSLogCollector class exists with collect() method that returns List[LogEntry].
WSCollectionError exception exists.
Both are exported from unifi_scanner.logs module.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from unifi_scanner.api import WebSocketManager"` succeeds
2. `python -c "from unifi_scanner.logs import WSLogCollector"` succeeds
3. `mypy src/unifi_scanner/api/ws_manager.py --ignore-missing-imports` passes
4. `mypy src/unifi_scanner/logs/ws_collector.py --ignore-missing-imports` passes
5. `ruff check src/unifi_scanner/api/ src/unifi_scanner/logs/` passes
</verification>

<success_criteria>
- WebSocketManager runs WebSocket in background thread
- _on_event callback wires client.listen() to buffer.add()
- drain_events() works from sync context
- WSLogCollector converts BufferedEvent to LogEntry
- Event type mappings produce meaningful log messages
- All code passes type checking and linting
</success_criteria>

<output>
After completion, create `.planning/phases/13-websocket-support/13-03-SUMMARY.md`
</output>
