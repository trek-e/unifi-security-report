---
phase: 13-websocket-support
plan: 06
type: execute
wave: 4
depends_on: ["13-04", "13-05"]
files_modified:
  - tests/test_ws_integration.py
  - tests/test_collector.py
autonomous: false

must_haves:
  truths:
    - "WebSocket fallback chain works correctly"
    - "WebSocket events appear in generated reports"
    - "Service handles WebSocket unavailable gracefully"
  artifacts:
    - path: "tests/test_ws_integration.py"
      provides: "Integration tests for WebSocket"
      min_lines: 60
  key_links:
    - from: "tests/test_ws_integration.py"
      to: "src/unifi_scanner/logs/collector.py"
      via: "LogCollector with mocked WebSocket"
      pattern: "LogCollector"
---

<objective>
Create integration tests and verify end-to-end WebSocket functionality.

Purpose: Ensure the complete WebSocket integration works as expected, including
the fallback chain, event processing, and report generation with WebSocket events.

Output:
- Integration test suite for WebSocket
- Updated collector tests for WS support
- Human verification of live WebSocket connection (if UniFi 10.x available)
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-websocket-support/13-04-SUMMARY.md
@.planning/phases/13-websocket-support/13-05-SUMMARY.md

# Test files
@tests/test_collector.py
@tests/test_websocket.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket integration tests</name>
  <files>tests/test_ws_integration.py</files>
  <action>
Create tests/test_ws_integration.py with:

**TestLogCollectorWithWebSocket class:**
Using mocked WebSocketManager and mocked REST client.

1. test_collector_uses_ws_when_available:
   - Mock ws_manager.drain_events() to return sample events
   - Mock API collector to return some events
   - Verify LogCollector merges both sources
   - Verify deduplication works

2. test_collector_falls_back_when_ws_empty:
   - Mock ws_manager.drain_events() to return []
   - Mock API collector to return events
   - Verify only API events returned

3. test_collector_falls_back_when_ws_error:
   - Mock ws_manager.drain_events() to raise WSCollectionError
   - Mock API collector to return events
   - Verify fallback works and events returned

4. test_collector_works_without_ws_manager:
   - Pass ws_manager=None to LogCollector
   - Verify it uses API-only (existing behavior)

5. test_ws_events_converted_to_logentry:
   - Create real BufferedEvent objects
   - Verify WSLogCollector converts them correctly
   - Check LogEntry fields are populated

**TestWebSocketManagerIntegration class:**
Test the thread-based WebSocket manager.

1. test_manager_starts_and_stops:
   - Create manager, call start() with mock websocket
   - Verify is_running() returns True
   - Call stop()
   - Verify is_running() returns False

2. test_drain_events_from_sync_context:
   - Mock websocket to buffer events
   - Call drain_events() from main thread
   - Verify events returned correctly

Use pytest fixtures and unittest.mock for WebSocket mocking.
  </action>
  <verify>
```bash
pytest tests/test_ws_integration.py -v
```
  </verify>
  <done>
All integration tests pass.
WebSocket fallback chain verified.
Event conversion verified.
Manager lifecycle verified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update existing collector tests</name>
  <files>tests/test_collector.py</files>
  <action>
Update tests/test_collector.py to account for new ws_manager parameter:

1. **Update existing tests:**
   - Ensure all LogCollector instantiations work with default ws_manager=None
   - Add explicit ws_manager=None where needed for clarity

2. **Add tests for graceful degradation:**
   - test_collector_without_websocket_still_works:
     - Verify existing API->SSH fallback chain unchanged
     - ws_manager=None should result in identical behavior to before

3. **Verify no regressions:**
   - Run full test suite
   - All existing tests should pass unchanged

The goal is backward compatibility - existing code that doesn't use WebSocket
should work identically.
  </action>
  <verify>
```bash
pytest tests/test_collector.py -v
pytest tests/ -v  # Full suite
```
  </verify>
  <done>
All existing tests pass.
New tests for ws_manager=None added.
No regressions in collector behavior.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete WebSocket support for UniFi Network 10.x+ WiFi events</what-built>
  <how-to-verify>
**If you have a UniFi Network 10.x+ controller available:**

1. Run the scanner against your controller:
   ```bash
   UNIFI_HOST=your-controller UNIFI_USERNAME=admin UNIFI_PASSWORD=xxx \
   python -m unifi_scanner
   ```

2. Check logs for WebSocket connection:
   - Look for "websocket_started" or "websocket_connected"
   - If "websocket_unavailable", your controller may not support it yet

3. Generate a report and check for WiFi events:
   - Client roaming, connections, disconnections should appear
   - Events from WebSocket will be merged with REST events

**If you only have UniFi 9.x or older:**
1. Verify the scanner still works in REST-only mode
2. Check that websocket_enabled=false config works:
   ```bash
   UNIFI_WEBSOCKET_ENABLED=false UNIFI_HOST=... python -m unifi_scanner
   ```
3. Logs should show "websocket_disabled"

**Alternative: Unit test verification only**
If no controller available, verify tests pass:
```bash
pytest tests/ -v --tb=short
```
  </how-to-verify>
  <resume-signal>Type "approved" after verification, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `pytest tests/ -v` - all tests pass
2. Integration tests cover fallback scenarios
3. Existing tests have no regressions
4. (If controller available) Live WebSocket connection works
</verification>

<success_criteria>
- All unit and integration tests pass
- WebSocket events appear in reports when connected
- Fallback to REST-only works when WebSocket unavailable
- No regressions in existing functionality
- User has verified live behavior (or confirmed tests sufficient)
</success_criteria>

<output>
After completion, create `.planning/phases/13-websocket-support/13-06-SUMMARY.md`
</output>
