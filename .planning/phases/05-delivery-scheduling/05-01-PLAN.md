---
phase: 05-delivery-scheduling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/unifi_scanner/config/settings.py
  - src/unifi_scanner/delivery/__init__.py
  - src/unifi_scanner/delivery/email.py
autonomous: true

must_haves:
  truths:
    - "Service can send HTML email with plaintext fallback via SMTP"
    - "All recipients receive email via BCC (no To/CC headers)"
    - "Subject line includes severity count when severe findings exist"
    - "Email delivery fails gracefully with logged error (no crash)"
  artifacts:
    - path: "src/unifi_scanner/delivery/email.py"
      provides: "EmailDelivery class for SMTP sending"
      exports: ["EmailDelivery"]
    - path: "src/unifi_scanner/delivery/__init__.py"
      provides: "Delivery module exports"
      exports: ["EmailDelivery"]
    - path: "src/unifi_scanner/config/settings.py"
      provides: "Email configuration settings"
      contains: "smtp_host"
  key_links:
    - from: "src/unifi_scanner/delivery/email.py"
      to: "smtplib"
      via: "stdlib SMTP/SMTP_SSL"
      pattern: "smtplib\\.SMTP"
    - from: "src/unifi_scanner/delivery/email.py"
      to: "email.message"
      via: "EmailMessage for multipart"
      pattern: "EmailMessage"
---

<objective>
Create SMTP email delivery system with BCC-only recipients and severity-aware subject lines.

Purpose: Enable automated report delivery via email with HTML and plaintext multipart format.
Output: EmailDelivery class that sends reports via SMTP with proper TLS support.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-scheduling/05-RESEARCH.md
@.planning/phases/05-delivery-scheduling/05-CONTEXT.md

# Existing files to extend/reference
@src/unifi_scanner/config/settings.py
@src/unifi_scanner/models/report.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email configuration to settings</name>
  <files>src/unifi_scanner/config/settings.py</files>
  <action>
Add email delivery settings to UnifiSettings class:

```python
# Email delivery settings
email_enabled: bool = Field(
    default=False,
    description="Enable email delivery of reports",
)
smtp_host: Optional[str] = Field(
    default=None,
    description="SMTP server hostname",
)
smtp_port: int = Field(
    default=587,
    description="SMTP server port (587 for STARTTLS, 465 for implicit TLS)",
    ge=1,
    le=65535,
)
smtp_user: Optional[str] = Field(
    default=None,
    description="SMTP authentication username",
)
smtp_password: Optional[str] = Field(
    default=None,
    description="SMTP authentication password",
)
smtp_use_tls: bool = Field(
    default=True,
    description="Use TLS for SMTP connection",
)
email_from: str = Field(
    default="unifi-scanner@localhost",
    description="From address for sent emails",
)
email_recipients: str = Field(
    default="",
    description="Comma-separated list of recipient email addresses (all via BCC)",
)
```

Add validator for email_recipients to convert comma-separated string to list when accessed.
Add validator for smtp configuration (if email_enabled, smtp_host is required).
  </action>
  <verify>
Run `python -c "from unifi_scanner.config.settings import UnifiSettings; print('imports ok')"` succeeds.
  </verify>
  <done>
Email settings exist in UnifiSettings with proper defaults and validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EmailDelivery class</name>
  <files>src/unifi_scanner/delivery/__init__.py, src/unifi_scanner/delivery/email.py</files>
  <action>
Create src/unifi_scanner/delivery/ directory and files.

In email.py, implement EmailDelivery class:

```python
"""SMTP email delivery for reports."""

import smtplib
import ssl
from datetime import datetime
from email.message import EmailMessage
from email.utils import formatdate
from typing import List, Optional

import structlog

from unifi_scanner.models.report import Report

log = structlog.get_logger()


class EmailDeliveryError(Exception):
    """Raised when email delivery fails."""
    pass


class EmailDelivery:
    """SMTP email delivery with BCC recipients and multipart support."""

    def __init__(
        self,
        smtp_host: str,
        smtp_port: int = 587,
        smtp_user: Optional[str] = None,
        smtp_password: Optional[str] = None,
        use_tls: bool = True,
        from_addr: str = "unifi-scanner@localhost",
        timezone: str = "UTC",
    ) -> None:
        """Initialize email delivery.

        Args:
            smtp_host: SMTP server hostname
            smtp_port: SMTP server port (587=STARTTLS, 465=implicit TLS)
            smtp_user: Authentication username
            smtp_password: Authentication password
            use_tls: Enable TLS encryption
            from_addr: Sender email address
            timezone: Timezone for date formatting in subject
        """
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.smtp_user = smtp_user
        self.smtp_password = smtp_password
        self.use_tls = use_tls
        self.from_addr = from_addr
        self.timezone = timezone

    def build_subject(self, report: Report) -> str:
        """Build email subject with optional severity prefix.

        Format: "[N SEVERE] UniFi Report - Jan 24, 2026"
        Or: "UniFi Report - Jan 24, 2026" (no severe findings)
        """
        from zoneinfo import ZoneInfo

        tz = ZoneInfo(self.timezone)
        date_str = report.generated_at.astimezone(tz).strftime("%b %d, %Y")

        if report.severe_count > 0:
            return f"[{report.severe_count} SEVERE] UniFi Report - {date_str}"
        return f"UniFi Report - {date_str}"

    def send(
        self,
        recipients: List[str],
        subject: str,
        html_content: str,
        text_content: str,
    ) -> None:
        """Send multipart email to BCC recipients.

        Args:
            recipients: List of email addresses (all BCC, never shown)
            subject: Email subject line
            html_content: HTML body content
            text_content: Plain text fallback content

        Raises:
            EmailDeliveryError: If sending fails
        """
        if not recipients:
            log.warning("email_skipped", reason="no recipients")
            return

        msg = EmailMessage()
        msg["Subject"] = subject
        msg["From"] = self.from_addr
        msg["Date"] = formatdate(localtime=True)
        # NOTE: No To/Cc headers - all recipients via BCC (hidden)

        # Set plaintext first, then add HTML alternative
        msg.set_content(text_content)
        msg.add_alternative(html_content, subtype="html")

        try:
            context = ssl.create_default_context()

            if self.use_tls and self.smtp_port == 465:
                # Implicit TLS (SMTPS)
                with smtplib.SMTP_SSL(self.smtp_host, self.smtp_port, context=context) as server:
                    if self.smtp_user and self.smtp_password:
                        server.login(self.smtp_user, self.smtp_password)
                    server.sendmail(self.from_addr, recipients, msg.as_string())
            else:
                # Explicit TLS (STARTTLS) or no TLS
                with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                    if self.use_tls:
                        server.starttls(context=context)
                    if self.smtp_user and self.smtp_password:
                        server.login(self.smtp_user, self.smtp_password)
                    server.sendmail(self.from_addr, recipients, msg.as_string())

            log.info("email_sent", recipients_count=len(recipients), subject=subject)

        except smtplib.SMTPAuthenticationError as e:
            log.error("email_auth_failed", error=str(e))
            raise EmailDeliveryError(f"SMTP authentication failed: {e}")
        except smtplib.SMTPException as e:
            log.error("email_send_failed", error=str(e))
            raise EmailDeliveryError(f"SMTP error: {e}")
        except Exception as e:
            log.error("email_delivery_error", error=str(e))
            raise EmailDeliveryError(f"Email delivery failed: {e}")

    def deliver_report(
        self,
        report: Report,
        html_content: str,
        text_content: str,
        recipients: List[str],
    ) -> bool:
        """Deliver report via email.

        Args:
            report: Report object for subject line generation
            html_content: Rendered HTML report
            text_content: Rendered plain text report
            recipients: List of recipient addresses

        Returns:
            True if delivery succeeded, False otherwise
        """
        subject = self.build_subject(report)
        try:
            self.send(recipients, subject, html_content, text_content)
            return True
        except EmailDeliveryError:
            return False
```

In __init__.py:
```python
"""Delivery subsystem for report output."""

from unifi_scanner.delivery.email import EmailDelivery, EmailDeliveryError

__all__ = ["EmailDelivery", "EmailDeliveryError"]
```
  </action>
  <verify>
Run `python -c "from unifi_scanner.delivery import EmailDelivery; print('imports ok')"` succeeds.
Run `python -c "from unifi_scanner.delivery.email import EmailDelivery; e = EmailDelivery('smtp.test.com'); print(e.build_subject.__doc__)"` succeeds.
  </verify>
  <done>
EmailDelivery class exists with send() method using smtplib, build_subject() with severity prefix, and BCC-only recipient handling.
  </done>
</task>

</tasks>

<verification>
- EmailDelivery can be instantiated with SMTP configuration
- build_subject() returns severity prefix when severe_count > 0
- No msg['Bcc'] header is set (recipients only in sendmail())
- Both port 587 (STARTTLS) and 465 (implicit TLS) are supported
- Delivery errors are caught and logged, not re-raised as crashes
</verification>

<success_criteria>
1. `from unifi_scanner.delivery import EmailDelivery` works
2. `from unifi_scanner.config.settings import UnifiSettings; s = UnifiSettings(host='x', username='y'); print(s.email_enabled)` returns False
3. EmailDelivery.send() uses smtplib with proper TLS handling
4. Subject line format matches "[N SEVERE] UniFi Report - DATE" when severe > 0
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-scheduling/05-01-SUMMARY.md`
</output>
