---
phase: 05-delivery-scheduling
plan: 05
type: execute
wave: 3
depends_on: ["05-04"]
files_modified:
  - tests/test_delivery_email.py
  - tests/test_delivery_file.py
  - tests/test_scheduler.py
  - tests/test_integration.py
autonomous: false

must_haves:
  truths:
    - "Email delivery sends multipart message with BCC recipients"
    - "File delivery saves with datetime filename and runs cleanup"
    - "Scheduler executes jobs on cron schedule"
    - "End-to-end integration works with all components"
  artifacts:
    - path: "tests/test_delivery_email.py"
      provides: "Email delivery unit tests"
      min_lines: 50
    - path: "tests/test_delivery_file.py"
      provides: "File delivery unit tests"
      min_lines: 50
    - path: "tests/test_scheduler.py"
      provides: "Scheduler unit tests"
      min_lines: 40
    - path: "tests/test_integration.py"
      provides: "End-to-end integration tests"
      min_lines: 30
  key_links:
    - from: "tests/test_delivery_email.py"
      to: "src/unifi_scanner/delivery/email.py"
      via: "EmailDelivery import"
      pattern: "from unifi_scanner.delivery"
    - from: "tests/test_integration.py"
      to: "src/unifi_scanner/delivery/manager.py"
      via: "DeliveryManager import"
      pattern: "DeliveryManager"
---

<objective>
Create comprehensive tests for delivery, scheduling, and end-to-end integration.

Purpose: Verify all Phase 5 components work correctly and handle edge cases.
Output: Test suite covering email, file, scheduler, and integration scenarios.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-scheduling/05-RESEARCH.md
@.planning/phases/05-delivery-scheduling/05-CONTEXT.md

# Implementation files to test
@src/unifi_scanner/delivery/email.py
@src/unifi_scanner/delivery/file.py
@src/unifi_scanner/delivery/manager.py
@src/unifi_scanner/scheduler/runner.py
@src/unifi_scanner/scheduler/presets.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email delivery tests</name>
  <files>tests/test_delivery_email.py</files>
  <action>
Create tests/test_delivery_email.py:

```python
"""Tests for email delivery."""

from datetime import datetime, timezone
from unittest.mock import MagicMock, patch
from uuid import uuid4

import pytest

from unifi_scanner.delivery.email import EmailDelivery, EmailDeliveryError
from unifi_scanner.models.enums import DeviceType, Severity
from unifi_scanner.models.finding import Finding
from unifi_scanner.models.report import Report


@pytest.fixture
def sample_report() -> Report:
    """Create sample report for testing."""
    return Report(
        id=uuid4(),
        generated_at=datetime(2026, 1, 24, 14, 30, tzinfo=timezone.utc),
        period_start=datetime(2026, 1, 23, 14, 30, tzinfo=timezone.utc),
        period_end=datetime(2026, 1, 24, 14, 30, tzinfo=timezone.utc),
        site_name="default",
        controller_type=DeviceType.UDM_PRO,
        findings=[],
        log_entry_count=100,
    )


@pytest.fixture
def severe_report(sample_report: Report) -> Report:
    """Create report with severe findings."""
    sample_report.findings = [
        Finding(
            event_type="EVT_IPS_Alert",
            severity=Severity.SEVERE,
            title="Test Severe",
            description="Test",
            first_seen=datetime.now(timezone.utc),
            last_seen=datetime.now(timezone.utc),
            occurrence_count=1,
        ),
        Finding(
            event_type="EVT_IPS_Alert_2",
            severity=Severity.SEVERE,
            title="Test Severe 2",
            description="Test",
            first_seen=datetime.now(timezone.utc),
            last_seen=datetime.now(timezone.utc),
            occurrence_count=1,
        ),
    ]
    return sample_report


class TestEmailDeliverySubject:
    """Test email subject line generation."""

    def test_subject_no_severe(self, sample_report: Report) -> None:
        """Subject without severity prefix when no severe findings."""
        delivery = EmailDelivery(smtp_host="test", timezone="UTC")
        subject = delivery.build_subject(sample_report)
        assert subject == "UniFi Report - Jan 24, 2026"
        assert "[" not in subject

    def test_subject_with_severe(self, severe_report: Report) -> None:
        """Subject with severity prefix when severe findings exist."""
        delivery = EmailDelivery(smtp_host="test", timezone="UTC")
        subject = delivery.build_subject(severe_report)
        assert subject == "[2 SEVERE] UniFi Report - Jan 24, 2026"

    def test_subject_timezone_formatting(self, sample_report: Report) -> None:
        """Subject uses configured timezone for date."""
        delivery = EmailDelivery(smtp_host="test", timezone="America/New_York")
        # 14:30 UTC = 09:30 EST, same day
        subject = delivery.build_subject(sample_report)
        assert "Jan 24, 2026" in subject


class TestEmailDeliverySend:
    """Test email sending functionality."""

    @patch("unifi_scanner.delivery.email.smtplib.SMTP")
    def test_send_starttls(self, mock_smtp: MagicMock) -> None:
        """Send email via STARTTLS (port 587)."""
        mock_server = MagicMock()
        mock_smtp.return_value.__enter__ = MagicMock(return_value=mock_server)
        mock_smtp.return_value.__exit__ = MagicMock(return_value=False)

        delivery = EmailDelivery(
            smtp_host="smtp.test.com",
            smtp_port=587,
            smtp_user="user",
            smtp_password="pass",
            use_tls=True,
        )

        delivery.send(
            recipients=["test@example.com"],
            subject="Test Subject",
            html_content="<p>HTML</p>",
            text_content="Text",
        )

        mock_smtp.assert_called_once()
        mock_server.starttls.assert_called_once()
        mock_server.login.assert_called_once_with("user", "pass")
        mock_server.sendmail.assert_called_once()

    @patch("unifi_scanner.delivery.email.smtplib.SMTP_SSL")
    def test_send_implicit_tls(self, mock_smtp_ssl: MagicMock) -> None:
        """Send email via implicit TLS (port 465)."""
        mock_server = MagicMock()
        mock_smtp_ssl.return_value.__enter__ = MagicMock(return_value=mock_server)
        mock_smtp_ssl.return_value.__exit__ = MagicMock(return_value=False)

        delivery = EmailDelivery(
            smtp_host="smtp.test.com",
            smtp_port=465,
            smtp_user="user",
            smtp_password="pass",
            use_tls=True,
        )

        delivery.send(
            recipients=["test@example.com"],
            subject="Test Subject",
            html_content="<p>HTML</p>",
            text_content="Text",
        )

        mock_smtp_ssl.assert_called_once()
        mock_server.sendmail.assert_called_once()

    def test_send_no_recipients_skipped(self) -> None:
        """Empty recipient list skips sending."""
        delivery = EmailDelivery(smtp_host="test")

        # Should not raise, just log warning
        delivery.send(
            recipients=[],
            subject="Test",
            html_content="<p>Test</p>",
            text_content="Test",
        )

    @patch("unifi_scanner.delivery.email.smtplib.SMTP")
    def test_bcc_not_in_headers(self, mock_smtp: MagicMock) -> None:
        """Recipients are NOT exposed in message headers."""
        mock_server = MagicMock()
        mock_smtp.return_value.__enter__ = MagicMock(return_value=mock_server)
        mock_smtp.return_value.__exit__ = MagicMock(return_value=False)

        delivery = EmailDelivery(smtp_host="test", smtp_port=587, use_tls=False)

        delivery.send(
            recipients=["secret@example.com", "hidden@example.com"],
            subject="Test",
            html_content="<p>Test</p>",
            text_content="Test",
        )

        # Get the message string passed to sendmail
        call_args = mock_server.sendmail.call_args
        msg_string = call_args[0][2]  # Third argument is message string

        # Verify Bcc header is NOT present
        assert "Bcc:" not in msg_string
        assert "secret@example.com" not in msg_string
        assert "hidden@example.com" not in msg_string
```
  </action>
  <verify>
Run `pytest tests/test_delivery_email.py -v` passes all tests.
  </verify>
  <done>
Email delivery tests cover subject generation, TLS modes, and BCC handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create file delivery and scheduler tests</name>
  <files>tests/test_delivery_file.py, tests/test_scheduler.py</files>
  <action>
Create tests/test_delivery_file.py:

```python
"""Tests for file delivery."""

import tempfile
from datetime import datetime, timedelta, timezone
from pathlib import Path
from uuid import uuid4

import pytest

from unifi_scanner.delivery.file import FileDelivery, FileDeliveryError
from unifi_scanner.models.enums import DeviceType
from unifi_scanner.models.report import Report


@pytest.fixture
def sample_report() -> Report:
    """Create sample report for testing."""
    return Report(
        id=uuid4(),
        generated_at=datetime(2026, 1, 24, 14, 30, tzinfo=timezone.utc),
        period_start=datetime(2026, 1, 23, 14, 30, tzinfo=timezone.utc),
        period_end=datetime(2026, 1, 24, 14, 30, tzinfo=timezone.utc),
        site_name="default",
        controller_type=DeviceType.UDM_PRO,
        findings=[],
        log_entry_count=100,
    )


@pytest.fixture
def temp_output_dir() -> Path:
    """Create temporary output directory."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


class TestFileDeliveryFilename:
    """Test filename generation."""

    def test_filename_format(self, sample_report: Report) -> None:
        """Filename follows datetime pattern."""
        delivery = FileDelivery(output_dir="/tmp", timezone="UTC")
        filename = delivery._generate_filename(sample_report, "html")
        assert filename == "unifi-report-2026-01-24-1430.html"

    def test_filename_timezone(self, sample_report: Report) -> None:
        """Filename uses configured timezone."""
        delivery = FileDelivery(output_dir="/tmp", timezone="America/New_York")
        # 14:30 UTC = 09:30 EST
        filename = delivery._generate_filename(sample_report, "html")
        assert filename == "unifi-report-2026-01-24-0930.html"


class TestFileDeliverySave:
    """Test file saving functionality."""

    def test_save_html_only(
        self, sample_report: Report, temp_output_dir: Path
    ) -> None:
        """Save only HTML when format is html."""
        delivery = FileDelivery(
            output_dir=str(temp_output_dir),
            file_format="html",
        )

        paths = delivery.save(
            report=sample_report,
            html_content="<p>HTML</p>",
            text_content="Text",
        )

        assert len(paths) == 1
        assert paths[0].suffix == ".html"
        assert paths[0].exists()
        assert paths[0].read_text() == "<p>HTML</p>"

    def test_save_text_only(
        self, sample_report: Report, temp_output_dir: Path
    ) -> None:
        """Save only text when format is text."""
        delivery = FileDelivery(
            output_dir=str(temp_output_dir),
            file_format="text",
        )

        paths = delivery.save(
            report=sample_report,
            html_content="<p>HTML</p>",
            text_content="Plain text content",
        )

        assert len(paths) == 1
        assert paths[0].suffix == ".txt"
        assert "Plain text content" in paths[0].read_text()

    def test_save_both_formats(
        self, sample_report: Report, temp_output_dir: Path
    ) -> None:
        """Save both formats when format is both."""
        delivery = FileDelivery(
            output_dir=str(temp_output_dir),
            file_format="both",
        )

        paths = delivery.save(
            report=sample_report,
            html_content="<p>HTML</p>",
            text_content="Text",
        )

        assert len(paths) == 2
        suffixes = {p.suffix for p in paths}
        assert suffixes == {".html", ".txt"}

    def test_creates_output_dir(self, sample_report: Report) -> None:
        """Creates output directory if it doesn't exist."""
        with tempfile.TemporaryDirectory() as tmpdir:
            new_dir = Path(tmpdir) / "nested" / "reports"
            delivery = FileDelivery(output_dir=str(new_dir))

            paths = delivery.save(
                report=sample_report,
                html_content="<p>HTML</p>",
                text_content="Text",
            )

            assert new_dir.exists()
            assert len(paths) > 0


class TestFileDeliveryCleanup:
    """Test retention cleanup."""

    def test_cleanup_old_files(self, temp_output_dir: Path) -> None:
        """Deletes files older than retention days."""
        delivery = FileDelivery(
            output_dir=str(temp_output_dir),
            retention_days=7,
        )

        # Create old file (simulate 10 days old)
        old_file = temp_output_dir / "unifi-report-2026-01-14-0800.html"
        old_file.write_text("old")
        # Set mtime to 10 days ago
        old_mtime = datetime.now().timestamp() - (10 * 24 * 60 * 60)
        import os
        os.utime(old_file, (old_mtime, old_mtime))

        # Create recent file
        recent_file = temp_output_dir / "unifi-report-2026-01-23-0800.html"
        recent_file.write_text("recent")

        deleted = delivery.cleanup_old_reports()

        assert deleted == 1
        assert not old_file.exists()
        assert recent_file.exists()

    def test_cleanup_zero_retention_keeps_all(self, temp_output_dir: Path) -> None:
        """Retention of 0 keeps all files."""
        delivery = FileDelivery(
            output_dir=str(temp_output_dir),
            retention_days=0,
        )

        old_file = temp_output_dir / "unifi-report-2020-01-01-0000.html"
        old_file.write_text("ancient")

        deleted = delivery.cleanup_old_reports()

        assert deleted == 0
        assert old_file.exists()
```

Create tests/test_scheduler.py:

```python
"""Tests for scheduler."""

from unittest.mock import MagicMock, patch

import pytest

from unifi_scanner.scheduler.presets import SCHEDULE_PRESETS, get_preset, list_presets
from unifi_scanner.scheduler.runner import ScheduledRunner, SchedulerError


class TestPresets:
    """Test schedule presets."""

    def test_list_presets(self) -> None:
        """Lists all available presets."""
        presets = list_presets()
        assert "daily_8am" in presets
        assert "weekly_monday_8am" in presets

    def test_get_preset_daily(self) -> None:
        """Get daily preset parameters."""
        params = get_preset("daily_8am")
        assert params is not None
        assert params["hour"] == 8
        assert params["minute"] == 0

    def test_get_preset_weekly(self) -> None:
        """Get weekly preset parameters."""
        params = get_preset("weekly_monday_8am")
        assert params is not None
        assert params["day_of_week"] == "mon"
        assert params["hour"] == 8

    def test_get_preset_unknown(self) -> None:
        """Unknown preset returns None."""
        assert get_preset("nonexistent") is None


class TestScheduledRunner:
    """Test scheduler runner."""

    def test_init_defaults(self) -> None:
        """Default initialization."""
        runner = ScheduledRunner()
        assert runner.timezone == "UTC"
        assert runner.misfire_grace_time == 3600

    def test_init_custom_timezone(self) -> None:
        """Custom timezone initialization."""
        runner = ScheduledRunner(timezone="America/New_York")
        assert runner.timezone == "America/New_York"

    def test_both_cron_and_preset_raises(self) -> None:
        """Cannot specify both cron and preset."""
        runner = ScheduledRunner()

        with pytest.raises(SchedulerError, match="Cannot specify both"):
            runner.run(
                func=lambda: None,
                cron_expr="0 8 * * *",
                preset="daily_8am",
            )

    @patch("unifi_scanner.scheduler.runner.BlockingScheduler")
    def test_run_with_preset(self, mock_scheduler_class: MagicMock) -> None:
        """Run with preset schedule."""
        mock_scheduler = MagicMock()
        mock_scheduler_class.return_value = mock_scheduler

        # Make start() raise to exit immediately
        mock_scheduler.start.side_effect = KeyboardInterrupt

        runner = ScheduledRunner(timezone="UTC")
        job_func = MagicMock()

        with pytest.raises(KeyboardInterrupt):
            runner.run(func=job_func, preset="daily_8am")

        mock_scheduler.add_job.assert_called_once()
        call_kwargs = mock_scheduler.add_job.call_args[1]
        assert call_kwargs["hour"] == 8
        assert call_kwargs["minute"] == 0

    @patch("unifi_scanner.scheduler.runner.BlockingScheduler")
    def test_run_with_cron(self, mock_scheduler_class: MagicMock) -> None:
        """Run with cron expression."""
        mock_scheduler = MagicMock()
        mock_scheduler_class.return_value = mock_scheduler
        mock_scheduler.start.side_effect = KeyboardInterrupt

        runner = ScheduledRunner(timezone="America/New_York")
        job_func = MagicMock()

        with pytest.raises(KeyboardInterrupt):
            runner.run(func=job_func, cron_expr="30 9 * * *")

        # Verify CronTrigger was used (via add_job with trigger)
        mock_scheduler.add_job.assert_called_once()

    @patch("unifi_scanner.scheduler.runner.BlockingScheduler")
    def test_one_shot_mode(self, mock_scheduler_class: MagicMock) -> None:
        """One-shot mode when no schedule specified."""
        mock_scheduler = MagicMock()
        mock_scheduler_class.return_value = mock_scheduler

        runner = ScheduledRunner()
        job_func = MagicMock()

        runner.run_once(job_func)

        # Verify date trigger used (one-shot)
        mock_scheduler.add_job.assert_called_once()
        call_args = mock_scheduler.add_job.call_args
        assert call_args[0][1] == "date"  # Trigger type
```
  </action>
  <verify>
Run `pytest tests/test_delivery_file.py tests/test_scheduler.py -v` passes all tests.
  </verify>
  <done>
File delivery and scheduler tests cover core functionality and edge cases.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 5 delivery and scheduling system with tests</what-built>
  <how-to-verify>
1. Run full test suite:
   ```bash
   pytest tests/test_delivery_*.py tests/test_scheduler.py -v
   ```
   All tests should pass.

2. Build Docker container:
   ```bash
   docker build -t unifi-scanner:test .
   ```
   Build should complete successfully.

3. Verify container runs:
   ```bash
   docker run --rm unifi-scanner:test --help
   ```
   Should show help message.

4. (Optional) Test with real UniFi controller:
   ```bash
   export UNIFI_HOST=your-controller-ip
   export UNIFI_USERNAME=admin
   export UNIFI_PASSWORD=your-password
   unifi-scanner --test
   ```
   Should validate configuration and connection.

5. Review docker-compose.yml for completeness - all options documented.
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 5, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
- All unit tests pass for email, file, and scheduler
- Docker build produces working container
- Container shows help message when run with --help
- docker-compose.yml documents all configuration options
- Test coverage includes edge cases (empty recipients, zero retention, etc.)
</verification>

<success_criteria>
1. `pytest tests/test_delivery_*.py tests/test_scheduler.py` passes
2. `docker build .` succeeds
3. `docker run --rm unifi-scanner --help` works
4. Human verification confirms complete functionality
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-scheduling/05-05-SUMMARY.md`
</output>
