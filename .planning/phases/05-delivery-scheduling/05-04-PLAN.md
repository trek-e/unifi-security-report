---
phase: 05-delivery-scheduling
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - src/unifi_scanner/__main__.py
  - src/unifi_scanner/delivery/manager.py
  - src/unifi_scanner/delivery/__init__.py
  - Dockerfile
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Service integrates scheduler, delivery, and report generation"
    - "Docker container runs with all dependencies bundled"
    - "docker-compose.yml provides complete reference with all options"
    - "Email failure triggers automatic file fallback"
  artifacts:
    - path: "src/unifi_scanner/delivery/manager.py"
      provides: "DeliveryManager orchestrating email and file delivery"
      exports: ["DeliveryManager"]
    - path: "src/unifi_scanner/__main__.py"
      provides: "Main entry point with scheduler integration"
      contains: "ScheduledRunner"
    - path: "Dockerfile"
      provides: "Multi-stage Docker build"
      contains: "python:3.12-slim-bookworm"
    - path: "docker-compose.yml"
      provides: "Complete deployment reference"
      contains: "UNIFI_SCHEDULE_PRESET"
  key_links:
    - from: "src/unifi_scanner/__main__.py"
      to: "src/unifi_scanner/scheduler/runner.py"
      via: "ScheduledRunner import"
      pattern: "ScheduledRunner"
    - from: "src/unifi_scanner/delivery/manager.py"
      to: "src/unifi_scanner/delivery/email.py"
      via: "EmailDelivery composition"
      pattern: "EmailDelivery"
    - from: "src/unifi_scanner/delivery/manager.py"
      to: "src/unifi_scanner/delivery/file.py"
      via: "FileDelivery composition"
      pattern: "FileDelivery"
---

<objective>
Create Docker container build and integrate all components into the main service loop.

Purpose: Enable production deployment as a scheduled Docker container with complete delivery pipeline.
Output: Working Dockerfile, docker-compose.yml, DeliveryManager, and integrated __main__.py.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-scheduling/05-RESEARCH.md
@.planning/phases/05-delivery-scheduling/05-CONTEXT.md

# Files from previous plans in this phase
@src/unifi_scanner/delivery/email.py
@src/unifi_scanner/delivery/file.py
@src/unifi_scanner/scheduler/runner.py
@src/unifi_scanner/__main__.py
@src/unifi_scanner/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DeliveryManager</name>
  <files>src/unifi_scanner/delivery/manager.py, src/unifi_scanner/delivery/__init__.py</files>
  <action>
Create manager.py with DeliveryManager class:

```python
"""Delivery orchestration for reports."""

from typing import List, Optional

import structlog

from unifi_scanner.delivery.email import EmailDelivery, EmailDeliveryError
from unifi_scanner.delivery.file import FileDelivery, FileDeliveryError
from unifi_scanner.models.report import Report

log = structlog.get_logger()


class DeliveryManager:
    """Orchestrates report delivery via email and/or file.

    Implements fallback logic: if email delivery fails, automatically
    saves to file even if file output wasn't configured.
    """

    def __init__(
        self,
        email_delivery: Optional[EmailDelivery] = None,
        file_delivery: Optional[FileDelivery] = None,
        fallback_dir: str = "./reports",
    ) -> None:
        """Initialize delivery manager.

        Args:
            email_delivery: Configured EmailDelivery instance (None = disabled)
            file_delivery: Configured FileDelivery instance (None = disabled)
            fallback_dir: Directory for file fallback when email fails
        """
        self.email_delivery = email_delivery
        self.file_delivery = file_delivery
        self.fallback_dir = fallback_dir

    def deliver(
        self,
        report: Report,
        html_content: str,
        text_content: str,
        email_recipients: Optional[List[str]] = None,
    ) -> bool:
        """Deliver report via configured channels.

        Email failure triggers file fallback (per CONTEXT.md decision).

        Args:
            report: Report object
            html_content: Rendered HTML report
            text_content: Rendered plain text report
            email_recipients: List of email addresses (for email delivery)

        Returns:
            True if at least one delivery succeeded, False if all failed
        """
        email_success = False
        file_success = False

        # Attempt email delivery
        if self.email_delivery and email_recipients:
            try:
                self.email_delivery.send(
                    recipients=email_recipients,
                    subject=self.email_delivery.build_subject(report),
                    html_content=html_content,
                    text_content=text_content,
                )
                email_success = True
                log.info("email_delivery_success", recipients_count=len(email_recipients))
            except EmailDeliveryError as e:
                log.error("email_delivery_failed", error=str(e))
                # Activate fallback if file delivery not configured
                if not self.file_delivery:
                    log.warning("activating_file_fallback", reason="email_failed")
                    self.file_delivery = FileDelivery(
                        output_dir=self.fallback_dir,
                        file_format="both",
                        retention_days=30,
                    )

        # File delivery (explicit or fallback)
        if self.file_delivery:
            try:
                paths = self.file_delivery.save(
                    report=report,
                    html_content=html_content,
                    text_content=text_content,
                )
                file_success = len(paths) > 0
                if file_success:
                    log.info("file_delivery_success", paths=[str(p) for p in paths])
            except FileDeliveryError as e:
                log.error("file_delivery_failed", error=str(e))

        # Log overall result
        if not email_success and not file_success:
            log.error("all_delivery_failed", message="No delivery method succeeded")

        return email_success or file_success
```

Update __init__.py to include DeliveryManager:
```python
"""Delivery subsystem for report output."""

from unifi_scanner.delivery.email import EmailDelivery, EmailDeliveryError
from unifi_scanner.delivery.file import FileDelivery, FileDeliveryError
from unifi_scanner.delivery.manager import DeliveryManager

__all__ = [
    "EmailDelivery",
    "EmailDeliveryError",
    "FileDelivery",
    "FileDeliveryError",
    "DeliveryManager",
]
```
  </action>
  <verify>
Run `python -c "from unifi_scanner.delivery import DeliveryManager; print('imports ok')"` succeeds.
  </verify>
  <done>
DeliveryManager exists with email + file delivery orchestration and fallback logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate scheduler into __main__.py</name>
  <files>src/unifi_scanner/__main__.py</files>
  <action>
Update __main__.py to integrate the scheduler and delivery system. Add a `run_report_job()` function that:
1. Connects to UniFi API
2. Collects logs
3. Analyzes logs
4. Generates report
5. Delivers via configured channels

Replace the "TODO: Phase 5 will add scheduling loop here" placeholder with actual scheduler integration:

```python
def run_report_job() -> None:
    """Execute one report generation and delivery cycle.

    This function is called by the scheduler on each scheduled run,
    or once in one-shot mode.
    """
    from unifi_scanner.api import UnifiClient
    from unifi_scanner.analysis.engine import AnalysisEngine
    from unifi_scanner.analysis.store import FindingStore
    from unifi_scanner.config.loader import get_config
    from unifi_scanner.delivery import DeliveryManager, EmailDelivery, FileDelivery
    from unifi_scanner.health import HealthStatus, update_health_status
    from unifi_scanner.logging import get_logger
    from unifi_scanner.logs.collector import LogCollector
    from unifi_scanner.models.enums import DeviceType
    from unifi_scanner.models.report import Report
    from unifi_scanner.reports.generator import ReportGenerator

    log = get_logger()
    config = get_config()

    log.info("job_starting")
    update_health_status(HealthStatus.HEALTHY, {"last_run": "starting"})

    try:
        # Connect and collect logs
        with UnifiClient(config) as client:
            site = client.select_site(config.site)

            # Collect logs
            collector = LogCollector(client, config)
            log_entries = collector.collect()
            log.info("logs_collected", count=len(log_entries))

            # Analyze logs
            store = FindingStore()
            engine = AnalysisEngine(store)
            for entry in log_entries:
                engine.analyze(entry)

            findings = store.get_all()
            log.info("analysis_complete", findings_count=len(findings))

            # Build report
            from datetime import datetime, timedelta
            now = datetime.utcnow()
            report = Report(
                period_start=now - timedelta(hours=24),
                period_end=now,
                site_name=site,
                controller_type=client.device_type or DeviceType.UNKNOWN,
                findings=findings,
                log_entry_count=len(log_entries),
            )

            # Generate report content
            generator = ReportGenerator(
                display_timezone=config.schedule_timezone,
            )
            html_content = generator.generate_html(report)
            text_content = generator.generate_text(report)

            # Set up delivery
            email_delivery = None
            if config.email_enabled and config.smtp_host:
                email_delivery = EmailDelivery(
                    smtp_host=config.smtp_host,
                    smtp_port=config.smtp_port,
                    smtp_user=config.smtp_user,
                    smtp_password=config.smtp_password,
                    use_tls=config.smtp_use_tls,
                    from_addr=config.email_from,
                    timezone=config.schedule_timezone,
                )

            file_delivery = None
            if config.file_enabled and config.file_output_dir:
                file_delivery = FileDelivery(
                    output_dir=config.file_output_dir,
                    file_format=config.file_format,
                    retention_days=config.file_retention_days,
                    timezone=config.schedule_timezone,
                )

            # Deliver
            manager = DeliveryManager(
                email_delivery=email_delivery,
                file_delivery=file_delivery,
            )

            recipients = []
            if config.email_recipients:
                recipients = [r.strip() for r in config.email_recipients.split(",") if r.strip()]

            success = manager.deliver(
                report=report,
                html_content=html_content,
                text_content=text_content,
                email_recipients=recipients,
            )

            if success:
                log.info("job_complete", status="success")
                update_health_status(HealthStatus.HEALTHY, {"last_run": "success"})
            else:
                log.warning("job_complete", status="delivery_failed")
                update_health_status(HealthStatus.UNHEALTHY, {"last_run": "delivery_failed"})

    except Exception as e:
        log.error("job_failed", error=str(e))
        update_health_status(HealthStatus.UNHEALTHY, {"last_run": str(e)})


def main() -> int:
    # ... existing argument parsing and config loading ...

    # In normal mode section, replace placeholder with:
    from unifi_scanner.scheduler import ScheduledRunner

    runner = ScheduledRunner(
        timezone=config.schedule_timezone,
    )

    log.info("service_starting", schedule_preset=config.schedule_preset, schedule_cron=config.schedule_cron)

    try:
        runner.run(
            func=run_report_job,
            cron_expr=config.schedule_cron,
            preset=config.schedule_preset,
        )
        return EXIT_SUCCESS
    except KeyboardInterrupt:
        log.info("shutdown", reason="keyboard interrupt")
        runner.shutdown()
        clear_health_status()
        return EXIT_SUCCESS
```

Ensure all imports are properly organized at the top of the file.
  </action>
  <verify>
Run `python -c "from unifi_scanner.__main__ import run_report_job; print('imports ok')"` succeeds.
Run `unifi-scanner --help` shows help message.
  </verify>
  <done>
__main__.py integrates scheduler and delivery system with complete report pipeline.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Dockerfile and docker-compose.yml</name>
  <files>Dockerfile, docker-compose.yml</files>
  <action>
Create Dockerfile with multi-stage build:

```dockerfile
# Stage 1: Build dependencies
FROM python:3.12-slim-bookworm AS builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && \
    apt-get install -y --no-install-recommends gcc && \
    rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Install Python dependencies
COPY pyproject.toml .
COPY src/ ./src/
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir .

# Stage 2: Production image
FROM python:3.12-slim-bookworm

WORKDIR /app

# Copy virtual environment from builder
COPY --from=builder /opt/venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Copy application code
COPY src/ ./src/

# Environment defaults
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    UNIFI_LOG_FORMAT=json

# Create non-root user
RUN useradd --create-home --shell /bin/bash appuser && \
    mkdir -p /app/reports && \
    chown -R appuser:appuser /app
USER appuser

# Health check
HEALTHCHECK --interval=60s --timeout=10s --retries=3 \
    CMD test -f /tmp/unifi-scanner-health && \
        python -c "import json; d=json.load(open('/tmp/unifi-scanner-health')); exit(0 if d.get('status')=='healthy' else 1)" \
    || exit 1

ENTRYPOINT ["unifi-scanner"]
```

Create docker-compose.yml with complete reference:

```yaml
# UniFi Scanner Docker Compose Configuration
# Full reference with all available options

services:
  unifi-scanner:
    build: .
    image: unifi-scanner:latest
    container_name: unifi-scanner
    restart: unless-stopped

    environment:
      # ===================
      # Connection (required)
      # ===================
      UNIFI_HOST: ${UNIFI_HOST:?UNIFI_HOST is required}
      UNIFI_USERNAME: ${UNIFI_USERNAME:?UNIFI_USERNAME is required}
      # UNIFI_PASSWORD: Use secret below instead of env var

      # ===================
      # Connection (optional)
      # ===================
      # Port auto-detection tries 443, 8443, 11443
      UNIFI_PORT: ${UNIFI_PORT:-}
      # Site auto-selected if only one exists
      UNIFI_SITE: ${UNIFI_SITE:-}
      # Set to false for self-signed certificates
      UNIFI_VERIFY_SSL: ${UNIFI_VERIFY_SSL:-true}

      # ===================
      # Scheduling
      # ===================
      # Use preset OR cron, not both
      # Presets: daily_8am, daily_6pm, weekly_monday_8am, weekly_friday_5pm
      UNIFI_SCHEDULE_PRESET: ${UNIFI_SCHEDULE_PRESET:-daily_8am}
      # Or use cron expression (5-field): "0 8 * * *" = 8am daily
      # UNIFI_SCHEDULE_CRON: ${UNIFI_SCHEDULE_CRON:-}
      # Timezone for schedule (IANA format)
      UNIFI_SCHEDULE_TIMEZONE: ${UNIFI_SCHEDULE_TIMEZONE:-UTC}

      # ===================
      # Email Delivery
      # ===================
      UNIFI_EMAIL_ENABLED: ${UNIFI_EMAIL_ENABLED:-false}
      UNIFI_SMTP_HOST: ${UNIFI_SMTP_HOST:-}
      UNIFI_SMTP_PORT: ${UNIFI_SMTP_PORT:-587}
      UNIFI_SMTP_USER: ${UNIFI_SMTP_USER:-}
      # UNIFI_SMTP_PASSWORD: Use secret below
      UNIFI_SMTP_USE_TLS: ${UNIFI_SMTP_USE_TLS:-true}
      UNIFI_EMAIL_FROM: ${UNIFI_EMAIL_FROM:-unifi-scanner@localhost}
      # Comma-separated list of recipients (all via BCC)
      UNIFI_EMAIL_RECIPIENTS: ${UNIFI_EMAIL_RECIPIENTS:-}

      # ===================
      # File Output
      # ===================
      UNIFI_FILE_ENABLED: ${UNIFI_FILE_ENABLED:-false}
      UNIFI_FILE_OUTPUT_DIR: ${UNIFI_FILE_OUTPUT_DIR:-/app/reports}
      # Format: html, text, or both
      UNIFI_FILE_FORMAT: ${UNIFI_FILE_FORMAT:-both}
      # Days to keep old reports (0 = forever)
      UNIFI_FILE_RETENTION_DAYS: ${UNIFI_FILE_RETENTION_DAYS:-30}

      # ===================
      # Logging
      # ===================
      UNIFI_LOG_LEVEL: ${UNIFI_LOG_LEVEL:-INFO}
      # Format: json (production) or text (debugging)
      UNIFI_LOG_FORMAT: json

    secrets:
      - unifi_password
      - smtp_password

    volumes:
      # Persist report files
      - ./reports:/app/reports:rw
      # Optional: custom config file
      # - ./config.yaml:/app/config.yaml:ro

    # Resource limits
    deploy:
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M

# Docker secrets (create files before running)
secrets:
  unifi_password:
    file: ./secrets/unifi_password.txt
  smtp_password:
    file: ./secrets/smtp_password.txt

# Example .env file:
# UNIFI_HOST=192.168.1.1
# UNIFI_USERNAME=admin
# UNIFI_SCHEDULE_PRESET=daily_8am
# UNIFI_SCHEDULE_TIMEZONE=America/New_York
# UNIFI_EMAIL_ENABLED=true
# UNIFI_SMTP_HOST=smtp.gmail.com
# UNIFI_SMTP_PORT=587
# UNIFI_SMTP_USER=your-email@gmail.com
# UNIFI_EMAIL_FROM=your-email@gmail.com
# UNIFI_EMAIL_RECIPIENTS=admin@example.com,ops@example.com
# UNIFI_FILE_ENABLED=true
```
  </action>
  <verify>
Run `docker build -t unifi-scanner:test .` completes successfully.
Run `docker run --rm unifi-scanner:test --help` shows help message.
  </verify>
  <done>
Dockerfile builds container with all dependencies. docker-compose.yml provides complete deployment reference.
  </done>
</task>

</tasks>

<verification>
- DeliveryManager.deliver() orchestrates email and file with fallback
- __main__.py run_report_job() executes complete pipeline
- Scheduler integration replaces placeholder in main()
- Docker build produces working container
- docker-compose.yml documents all environment variables
- Secrets supported via /run/secrets/ paths
</verification>

<success_criteria>
1. `docker build -t unifi-scanner .` succeeds
2. `docker run --rm unifi-scanner --help` shows CLI help
3. `docker run --rm unifi-scanner --test` (with valid config) validates connection
4. docker-compose.yml contains all UNIFI_* environment options
5. Image size under 200MB
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-scheduling/05-04-SUMMARY.md`
</output>
