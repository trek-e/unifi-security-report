---
phase: 05-delivery-scheduling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/unifi_scanner/config/settings.py
  - src/unifi_scanner/delivery/file.py
  - src/unifi_scanner/delivery/__init__.py
autonomous: true

must_haves:
  truths:
    - "Service saves reports to configurable output directory"
    - "File names include datetime (e.g., unifi-report-2026-01-24-1430.html)"
    - "Old files beyond retention period are automatically deleted"
    - "Both HTML and text formats can be saved based on configuration"
  artifacts:
    - path: "src/unifi_scanner/delivery/file.py"
      provides: "FileDelivery class for file output"
      exports: ["FileDelivery"]
    - path: "src/unifi_scanner/config/settings.py"
      provides: "File output configuration settings"
      contains: "file_output_dir"
  key_links:
    - from: "src/unifi_scanner/delivery/file.py"
      to: "pathlib"
      via: "Path for file operations"
      pattern: "Path\\("
    - from: "src/unifi_scanner/delivery/file.py"
      to: "file system"
      via: "write_text for atomic save"
      pattern: "\\.write_text\\("
---

<objective>
Create file output system with datetime-based naming and automatic retention cleanup.

Purpose: Enable saving reports to local filesystem with configurable retention policy.
Output: FileDelivery class that saves HTML/text reports and cleans old files.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-scheduling/05-RESEARCH.md
@.planning/phases/05-delivery-scheduling/05-CONTEXT.md

# Existing files to extend/reference
@src/unifi_scanner/config/settings.py
@src/unifi_scanner/models/report.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add file output configuration to settings</name>
  <files>src/unifi_scanner/config/settings.py</files>
  <action>
Add file output settings to UnifiSettings class:

```python
# File output settings
file_enabled: bool = Field(
    default=False,
    description="Enable file output of reports",
)
file_output_dir: Optional[str] = Field(
    default=None,
    description="Directory path for report file output",
)
file_format: Literal["html", "text", "both"] = Field(
    default="both",
    description="Report format(s) to save: html, text, or both",
)
file_retention_days: int = Field(
    default=30,
    description="Number of days to retain report files (0 = keep forever)",
    ge=0,
)
```

Add Literal import if not present.
Add validator: if file_enabled, file_output_dir is required.
  </action>
  <verify>
Run `python -c "from unifi_scanner.config.settings import UnifiSettings; print('imports ok')"` succeeds.
  </verify>
  <done>
File output settings exist in UnifiSettings with format options and retention config.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FileDelivery class</name>
  <files>src/unifi_scanner/delivery/file.py, src/unifi_scanner/delivery/__init__.py</files>
  <action>
Create file.py with FileDelivery class:

```python
"""File-based report delivery with retention management."""

from datetime import datetime, timedelta
from pathlib import Path
from typing import Literal, Optional
import tempfile
import shutil

import structlog

from unifi_scanner.models.report import Report

log = structlog.get_logger()


class FileDeliveryError(Exception):
    """Raised when file delivery fails."""
    pass


class FileDelivery:
    """File output delivery with datetime naming and retention cleanup."""

    def __init__(
        self,
        output_dir: str,
        file_format: Literal["html", "text", "both"] = "both",
        retention_days: int = 30,
        timezone: str = "UTC",
    ) -> None:
        """Initialize file delivery.

        Args:
            output_dir: Directory path for report output
            file_format: Format(s) to save - html, text, or both
            retention_days: Days to retain files (0 = keep forever)
            timezone: Timezone for filename timestamps
        """
        self.output_dir = Path(output_dir)
        self.file_format = file_format
        self.retention_days = retention_days
        self.timezone = timezone

    def _ensure_output_dir(self) -> None:
        """Create output directory if it doesn't exist."""
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def _generate_filename(self, report: Report, extension: str) -> str:
        """Generate datetime-based filename.

        Format: unifi-report-2026-01-24-1430.html
        """
        from zoneinfo import ZoneInfo

        tz = ZoneInfo(self.timezone)
        timestamp = report.generated_at.astimezone(tz)
        date_str = timestamp.strftime("%Y-%m-%d-%H%M")
        return f"unifi-report-{date_str}.{extension}"

    def _atomic_write(self, path: Path, content: str) -> None:
        """Write file atomically (write to temp, then rename).

        Prevents partial writes and cleanup race conditions.
        """
        # Write to temp file in same directory (for same-filesystem rename)
        temp_fd, temp_path = tempfile.mkstemp(
            dir=self.output_dir,
            prefix=".tmp-",
            suffix=path.suffix,
        )
        try:
            with open(temp_fd, "w", encoding="utf-8") as f:
                f.write(content)
            # Atomic rename (same filesystem)
            shutil.move(temp_path, path)
        except Exception:
            # Clean up temp file on failure
            Path(temp_path).unlink(missing_ok=True)
            raise

    def cleanup_old_reports(self) -> int:
        """Delete report files older than retention_days.

        Returns count of files deleted.
        """
        if self.retention_days <= 0:
            return 0  # Keep forever

        if not self.output_dir.exists():
            return 0

        cutoff = datetime.now() - timedelta(days=self.retention_days)
        deleted_count = 0

        # Clean up both HTML and text files
        for pattern in ["unifi-report-*.html", "unifi-report-*.txt"]:
            for file_path in self.output_dir.glob(pattern):
                try:
                    mtime = datetime.fromtimestamp(file_path.stat().st_mtime)
                    if mtime < cutoff:
                        file_path.unlink()
                        deleted_count += 1
                        log.debug(
                            "deleted_old_report",
                            path=str(file_path),
                            age_days=(datetime.now() - mtime).days,
                        )
                except (OSError, PermissionError) as e:
                    log.warning("cleanup_failed", path=str(file_path), error=str(e))

        if deleted_count > 0:
            log.info(
                "cleanup_complete",
                deleted=deleted_count,
                retention_days=self.retention_days,
            )

        return deleted_count

    def save(
        self,
        report: Report,
        html_content: Optional[str] = None,
        text_content: Optional[str] = None,
    ) -> list[Path]:
        """Save report to file(s) based on configured format.

        Args:
            report: Report object for filename generation
            html_content: Rendered HTML report (required if format includes html)
            text_content: Rendered text report (required if format includes text)

        Returns:
            List of paths to saved files

        Raises:
            FileDeliveryError: If saving fails
        """
        self._ensure_output_dir()
        saved_paths: list[Path] = []

        try:
            if self.file_format in ("html", "both") and html_content:
                html_filename = self._generate_filename(report, "html")
                html_path = self.output_dir / html_filename
                self._atomic_write(html_path, html_content)
                saved_paths.append(html_path)
                log.info("report_saved", path=str(html_path), format="html")

            if self.file_format in ("text", "both") and text_content:
                text_filename = self._generate_filename(report, "txt")
                text_path = self.output_dir / text_filename
                self._atomic_write(text_path, text_content)
                saved_paths.append(text_path)
                log.info("report_saved", path=str(text_path), format="text")

            # Run cleanup after successful save
            self.cleanup_old_reports()

            return saved_paths

        except PermissionError as e:
            log.error("file_permission_error", path=str(self.output_dir), error=str(e))
            raise FileDeliveryError(f"Permission denied writing to {self.output_dir}: {e}")
        except OSError as e:
            log.error("file_write_error", error=str(e))
            raise FileDeliveryError(f"Failed to write report file: {e}")

    def deliver_report(
        self,
        report: Report,
        html_content: Optional[str] = None,
        text_content: Optional[str] = None,
    ) -> bool:
        """Deliver report via file output.

        Args:
            report: Report object for filename generation
            html_content: Rendered HTML report
            text_content: Rendered text report

        Returns:
            True if at least one file was saved, False otherwise
        """
        try:
            paths = self.save(report, html_content, text_content)
            return len(paths) > 0
        except FileDeliveryError:
            return False
```

Update __init__.py to include FileDelivery:
```python
"""Delivery subsystem for report output."""

from unifi_scanner.delivery.email import EmailDelivery, EmailDeliveryError
from unifi_scanner.delivery.file import FileDelivery, FileDeliveryError

__all__ = ["EmailDelivery", "EmailDeliveryError", "FileDelivery", "FileDeliveryError"]
```
  </action>
  <verify>
Run `python -c "from unifi_scanner.delivery import FileDelivery; print('imports ok')"` succeeds.
Run `python -c "from unifi_scanner.delivery.file import FileDelivery; f = FileDelivery('/tmp/test'); print(f._generate_filename.__doc__)"` succeeds.
  </verify>
  <done>
FileDelivery class exists with save() method, datetime filename generation, atomic writes, and retention cleanup.
  </done>
</task>

</tasks>

<verification>
- FileDelivery can be instantiated with output directory
- _generate_filename() returns format "unifi-report-YYYY-MM-DD-HHMM.ext"
- Atomic write uses temp file then rename (prevents partial files)
- cleanup_old_reports() deletes files older than retention_days
- Both HTML and text formats supported based on file_format setting
</verification>

<success_criteria>
1. `from unifi_scanner.delivery import FileDelivery` works
2. `from unifi_scanner.config.settings import UnifiSettings; s = UnifiSettings(host='x', username='y'); print(s.file_enabled)` returns False
3. FileDelivery.save() writes files with datetime-based names
4. Retention cleanup removes files older than configured days
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-scheduling/05-02-SUMMARY.md`
</output>
