---
phase: 02-log-collection-parsing
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/unifi_scanner/logs/ssh_collector.py
  - src/unifi_scanner/logs/api_collector.py
  - src/unifi_scanner/logs/collector.py
  - src/unifi_scanner/logs/__init__.py
  - src/unifi_scanner/config/settings.py
  - tests/test_collectors.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "SSH collector can connect to UniFi device and read log files"
    - "API collector retrieves events and alarms and parses them to LogEntry"
    - "Fallback chain tries API first, falls back to SSH on failure"
    - "SSH operations have configurable timeouts to prevent hanging"
    - "Collector returns LogEntry objects regardless of source"
  artifacts:
    - path: "src/unifi_scanner/logs/ssh_collector.py"
      provides: "SSH-based log collection"
      exports: ["SSHLogCollector"]
    - path: "src/unifi_scanner/logs/api_collector.py"
      provides: "API-based log collection"
      exports: ["APILogCollector"]
    - path: "src/unifi_scanner/logs/collector.py"
      provides: "Orchestrating collector with fallback"
      exports: ["LogCollector"]
  key_links:
    - from: "src/unifi_scanner/logs/collector.py"
      to: "src/unifi_scanner/logs/api_collector.py"
      via: "APILogCollector as primary source"
      pattern: "APILogCollector"
    - from: "src/unifi_scanner/logs/collector.py"
      to: "src/unifi_scanner/logs/ssh_collector.py"
      via: "SSHLogCollector as fallback"
      pattern: "SSHLogCollector"
    - from: "src/unifi_scanner/logs/api_collector.py"
      to: "src/unifi_scanner/api/client.py"
      via: "UnifiClient.get_events() and get_alarms()"
      pattern: "client\\.get_events"
---

<objective>
Implement SSH fallback collector and orchestrating LogCollector with fallback chain.

Purpose: The UniFi API may not provide sufficient log access in all scenarios (per requirement COLL-04). SSH provides direct access to device log files as a fallback. This plan implements the collector strategy pattern with API as primary and SSH as fallback.

Output: SSHLogCollector for direct device access, APILogCollector wrapping UnifiClient methods, and LogCollector orchestrating both with automatic fallback on API failure or insufficient data.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-log-collection-parsing/02-RESEARCH.md

# Prior plan outputs (will exist at execution time)
@.planning/phases/02-log-collection-parsing/02-01-SUMMARY.md
@.planning/phases/02-log-collection-parsing/02-02-SUMMARY.md

# Key existing files
@src/unifi_scanner/api/client.py
@src/unifi_scanner/logs/parser.py
@src/unifi_scanner/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add paramiko dependency and SSH settings</name>
  <files>
pyproject.toml
src/unifi_scanner/config/settings.py
  </files>
  <action>
1. Add paramiko to dependencies in pyproject.toml:
   - Add `"paramiko>=3.4"` to the dependencies list

2. Update UnifiSettings in settings.py to add SSH configuration:
   - Add `ssh_username: Optional[str] = Field(default=None, description="SSH username for fallback (usually 'root')")`
   - Add `ssh_password: Optional[str] = Field(default=None, description="SSH password for fallback")`
   - Add `ssh_timeout: float = Field(default=30.0, ge=5.0, le=300.0, description="SSH command timeout in seconds")`
   - Add `ssh_enabled: bool = Field(default=True, description="Enable SSH fallback when API is insufficient")`

Note: SSH credentials default to None, meaning SSH fallback is only attempted if explicitly configured. The ssh_enabled flag allows disabling fallback even when credentials are provided.
  </action>
  <verify>
Run: `python -c "from unifi_scanner.config import UnifiSettings; s = UnifiSettings(host='x', username='u', password='p'); print(s.ssh_timeout, s.ssh_enabled)"`
Should print: `30.0 True`
  </verify>
  <done>
paramiko is added to dependencies and UnifiSettings includes SSH configuration fields with sensible defaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SSHLogCollector</name>
  <files>src/unifi_scanner/logs/ssh_collector.py</files>
  <action>
Create SSH collector that reads log files from UniFi devices:

```python
"""SSH-based log collection from UniFi devices."""

from typing import List, Optional

import paramiko
import structlog

from unifi_scanner.models import LogEntry, DeviceType
from .parser import LogParser

logger = structlog.get_logger(__name__)

# Log file paths by device type
LOG_PATHS = {
    DeviceType.UDM_PRO: [
        "/mnt/data/unifi-os/unifi-core/logs/system.log",
        "/var/log/messages",
    ],
    DeviceType.SELF_HOSTED: [
        "/var/log/unifi/server.log",
    ],
}


class SSHLogCollector:
    """Collect logs from UniFi devices via SSH.

    Connects to the device directly and reads log files.
    Used as fallback when API access is insufficient.
    """

    def __init__(
        self,
        host: str,
        username: str,
        password: str,
        device_type: DeviceType,
        timeout: float = 30.0,
    ) -> None:
        self.host = host
        self.username = username
        self.password = password
        self.device_type = device_type
        self.timeout = timeout
        self._parser = LogParser()

    def collect(self, max_lines: int = 10000) -> List[LogEntry]:
        """Collect logs from device via SSH.

        Args:
            max_lines: Maximum lines to read from each log file

        Returns:
            List of LogEntry objects parsed from log files

        Raises:
            SSHCollectionError: SSH connection or command failed
        """
        entries: List[LogEntry] = []
        log_paths = LOG_PATHS.get(self.device_type, [])

        if not log_paths:
            logger.warning("no_log_paths_configured", device_type=self.device_type.value)
            return entries

        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            logger.debug("ssh_connecting", host=self.host)
            client.connect(
                hostname=self.host,
                username=self.username,
                password=self.password,
                timeout=self.timeout,
                allow_agent=False,
                look_for_keys=False,
            )

            for log_path in log_paths:
                try:
                    content = self._read_log_file(client, log_path, max_lines)
                    if content:
                        parsed = self._parser.parse_syslog_lines(content)
                        entries.extend(parsed)
                        logger.debug(
                            "log_file_parsed",
                            path=log_path,
                            entries=len(parsed),
                        )
                except Exception as e:
                    logger.warning(
                        "log_file_read_failed",
                        path=log_path,
                        error=str(e),
                    )

            logger.info("ssh_collection_complete", total_entries=len(entries))
            return entries

        except paramiko.AuthenticationException as e:
            logger.error("ssh_auth_failed", host=self.host, error=str(e))
            raise SSHCollectionError(f"SSH authentication failed: {e}")
        except paramiko.SSHException as e:
            logger.error("ssh_connection_failed", host=self.host, error=str(e))
            raise SSHCollectionError(f"SSH connection failed: {e}")
        except Exception as e:
            logger.error("ssh_unexpected_error", host=self.host, error=str(e))
            raise SSHCollectionError(f"SSH collection failed: {e}")
        finally:
            client.close()

    def _read_log_file(
        self,
        client: paramiko.SSHClient,
        log_path: str,
        max_lines: int,
    ) -> str:
        """Read log file contents via SSH.

        Uses tail to limit output and prevent memory issues.
        Sets channel timeout to prevent deadlock.
        """
        command = f"tail -n {max_lines} {log_path}"

        stdin, stdout, stderr = client.exec_command(command, timeout=self.timeout)

        # Set channel timeout to prevent deadlock on large output
        stdout.channel.settimeout(self.timeout)
        stderr.channel.settimeout(self.timeout)

        output = stdout.read().decode('utf-8', errors='replace')
        error = stderr.read().decode('utf-8', errors='replace')

        if error and "No such file" not in error:
            logger.debug("ssh_stderr", path=log_path, error=error[:200])

        return output


class SSHCollectionError(Exception):
    """SSH log collection failed."""
    pass
```

Export SSHLogCollector and SSHCollectionError from logs/__init__.py.
  </action>
  <verify>
Run: `python -c "from unifi_scanner.logs import SSHLogCollector; print('SSHLogCollector imported')"`
Should print: `SSHLogCollector imported`
  </verify>
  <done>
SSHLogCollector connects to UniFi devices via SSH, reads log files based on device type, parses syslog format, and handles errors gracefully with proper timeouts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement APILogCollector and LogCollector with fallback</name>
  <files>
src/unifi_scanner/logs/api_collector.py
src/unifi_scanner/logs/collector.py
src/unifi_scanner/logs/__init__.py
tests/test_collectors.py
  </files>
  <action>
1. Create `src/unifi_scanner/logs/api_collector.py`:

```python
"""API-based log collection from UniFi controller."""

from typing import List

import structlog

from unifi_scanner.api import UnifiClient
from unifi_scanner.models import LogEntry
from .parser import LogParser

logger = structlog.get_logger(__name__)


class APILogCollector:
    """Collect logs from UniFi API (events and alarms)."""

    def __init__(self, client: UnifiClient, site: str) -> None:
        self.client = client
        self.site = site
        self._parser = LogParser()

    def collect(self, history_hours: int = 24) -> List[LogEntry]:
        """Collect logs via API.

        Args:
            history_hours: How far back to retrieve events

        Returns:
            List of LogEntry objects from events and alarms
        """
        entries: List[LogEntry] = []

        # Get events
        try:
            events = self.client.get_events(self.site, history_hours=history_hours)
            parsed_events = self._parser.parse_api_events(events)
            entries.extend(parsed_events)
            logger.debug("api_events_collected", count=len(parsed_events))
        except Exception as e:
            logger.warning("api_events_failed", error=str(e))

        # Get alarms
        try:
            alarms = self.client.get_alarms(self.site)
            parsed_alarms = self._parser.parse_api_events(alarms)
            entries.extend(parsed_alarms)
            logger.debug("api_alarms_collected", count=len(parsed_alarms))
        except Exception as e:
            logger.warning("api_alarms_failed", error=str(e))

        logger.info("api_collection_complete", total_entries=len(entries))
        return entries
```

2. Create `src/unifi_scanner/logs/collector.py`:

```python
"""Log collector with API primary and SSH fallback."""

from typing import List, Optional

import structlog

from unifi_scanner.api import UnifiClient
from unifi_scanner.config import UnifiSettings
from unifi_scanner.models import LogEntry
from .api_collector import APILogCollector
from .ssh_collector import SSHLogCollector, SSHCollectionError

logger = structlog.get_logger(__name__)


class LogCollector:
    """Orchestrates log collection with fallback strategy.

    Primary: API-based collection (events + alarms)
    Fallback: SSH-based collection (when configured and API fails/insufficient)
    """

    def __init__(
        self,
        client: UnifiClient,
        settings: UnifiSettings,
        site: str,
        min_entries: int = 10,
    ) -> None:
        """Initialize collector.

        Args:
            client: Connected UnifiClient
            settings: Configuration including SSH credentials
            site: Site name to collect from
            min_entries: Minimum entries before considering API "insufficient"
        """
        self.client = client
        self.settings = settings
        self.site = site
        self.min_entries = min_entries

        self._api_collector = APILogCollector(client, site)
        self._ssh_collector: Optional[SSHLogCollector] = None

        # Initialize SSH collector if configured
        if settings.ssh_enabled and settings.ssh_username and settings.ssh_password:
            if client.device_type:
                self._ssh_collector = SSHLogCollector(
                    host=settings.host,
                    username=settings.ssh_username,
                    password=settings.ssh_password,
                    device_type=client.device_type,
                    timeout=settings.ssh_timeout,
                )
                logger.debug("ssh_fallback_configured")

    def collect(self, history_hours: int = 24) -> List[LogEntry]:
        """Collect logs with automatic fallback.

        Tries API first. Falls back to SSH if:
        - API collection fails completely
        - API returns fewer than min_entries

        Args:
            history_hours: How far back to retrieve

        Returns:
            List of LogEntry objects

        Raises:
            LogCollectionError: Both API and SSH failed
        """
        # Try API first
        try:
            entries = self._api_collector.collect(history_hours)
            if len(entries) >= self.min_entries:
                logger.info(
                    "collection_complete",
                    source="api",
                    entries=len(entries),
                )
                return entries
            logger.info(
                "api_insufficient",
                entries=len(entries),
                min_required=self.min_entries,
            )
        except Exception as e:
            logger.warning("api_collection_failed", error=str(e))
            entries = []

        # Fall back to SSH if configured
        if self._ssh_collector:
            logger.info("falling_back_to_ssh")
            try:
                ssh_entries = self._ssh_collector.collect()
                # Combine API entries (if any) with SSH entries
                all_entries = entries + ssh_entries
                logger.info(
                    "collection_complete",
                    source="api+ssh" if entries else "ssh",
                    entries=len(all_entries),
                )
                return all_entries
            except SSHCollectionError as e:
                logger.error("ssh_fallback_failed", error=str(e))

        # If we have any entries from API, return them
        if entries:
            logger.warning(
                "partial_collection",
                entries=len(entries),
                ssh_available=self._ssh_collector is not None,
            )
            return entries

        raise LogCollectionError(
            "Log collection failed: API returned no data and SSH fallback "
            + ("failed" if self._ssh_collector else "not configured")
        )


class LogCollectionError(Exception):
    """Log collection failed from all sources."""
    pass
```

3. Update `src/unifi_scanner/logs/__init__.py`:
   - Export LogParser, LogCollector, APILogCollector, SSHLogCollector
   - Export LogCollectionError, SSHCollectionError

4. Create `tests/test_collectors.py`:
   - Test APILogCollector.collect() with mocked UnifiClient
   - Test LogCollector falls back to SSH when API returns few entries
   - Test LogCollector raises LogCollectionError when both fail
   - Test SSHLogCollector not used when ssh_enabled=False
  </action>
  <verify>
Run: `pytest tests/test_collectors.py -v`
All tests should pass.

Run: `python -c "from unifi_scanner.logs import LogCollector, LogCollectionError; print('collectors imported')"`
Should print: `collectors imported`
  </verify>
  <done>
APILogCollector wraps UnifiClient methods, LogCollector orchestrates with automatic SSH fallback, and tests verify the fallback chain behavior.
  </done>
</task>

</tasks>

<verification>
1. `pip install -e .` - install with new paramiko dependency
2. `python -c "from unifi_scanner.logs import LogCollector, APILogCollector, SSHLogCollector"` - imports work
3. `pytest tests/test_collectors.py -v` - all tests pass
4. `python -c "from unifi_scanner.config import UnifiSettings; s = UnifiSettings(host='x', username='u', password='p', ssh_username='root', ssh_password='sshpass'); print(s.ssh_enabled)"` - SSH settings work
</verification>

<success_criteria>
- paramiko added to project dependencies
- SSH settings added to UnifiSettings with sensible defaults
- SSHLogCollector connects to devices and reads logs with proper timeouts
- APILogCollector retrieves events and alarms via UnifiClient
- LogCollector tries API first, falls back to SSH when configured
- Fallback triggers on API failure or insufficient entries
- LogCollectionError raised when all sources fail
- Tests cover fallback logic and error handling
</success_criteria>

<output>
After completion, create `.planning/phases/02-log-collection-parsing/02-03-SUMMARY.md`
</output>
