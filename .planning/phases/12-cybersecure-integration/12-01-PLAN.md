---
phase: 12-cybersecure-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/unifi_scanner/analysis/ips/models.py
  - tests/test_ips_models.py
autonomous: true

must_haves:
  truths:
    - "IPSEvent with signature_id in 2800000-2899999 has is_cybersecure=True"
    - "IPSEvent with signature_id outside ET PRO range has is_cybersecure=False"
    - "is_cybersecure is computed from signature_id automatically"
  artifacts:
    - path: "src/unifi_scanner/analysis/ips/models.py"
      provides: "IPSEvent with is_cybersecure computed field"
      contains: "ET_PRO_SID_MIN"
    - path: "tests/test_ips_models.py"
      provides: "Tests for Cybersecure SID detection"
      contains: "test_is_cybersecure"
  key_links:
    - from: "IPSEvent.is_cybersecure"
      to: "signature_id"
      via: "computed_field with range check"
      pattern: "2800000.*2899999"
---

<objective>
Add Cybersecure signature detection to IPSEvent model via computed field

Purpose: Enable identification of threat findings detected by Cybersecure (Proofpoint ET PRO) enhanced signatures based on SID range 2800000-2899999
Output: IPSEvent model with `is_cybersecure` computed field that returns True for ET PRO signatures
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-cybersecure-integration/12-RESEARCH.md

# Existing IPS models to extend
@src/unifi_scanner/analysis/ips/models.py
@tests/test_ips_models.py
</context>

<feature>
  <name>Cybersecure Signature Detection on IPSEvent</name>
  <files>src/unifi_scanner/analysis/ips/models.py, tests/test_ips_models.py</files>
  <behavior>
    IPSEvent should have an `is_cybersecure` computed property that returns:
    - True when signature_id is in range 2800000-2899999 (ET PRO signatures)
    - False otherwise (ET Open signatures 2000000-2099999, custom, etc.)

    Test cases:
    - signature_id=2800000 (boundary min) -> is_cybersecure=True
    - signature_id=2850000 (middle) -> is_cybersecure=True
    - signature_id=2899999 (boundary max) -> is_cybersecure=True
    - signature_id=2799999 (just below) -> is_cybersecure=False
    - signature_id=2900000 (just above) -> is_cybersecure=False
    - signature_id=2001000 (ET Open) -> is_cybersecure=False
    - signature_id=100 (custom) -> is_cybersecure=False
  </behavior>
  <implementation>
    1. Add SID range constants at module level:
       ET_PRO_SID_MIN = 2800000
       ET_PRO_SID_MAX = 2899999

    2. Add computed_field to IPSEvent class:
       @computed_field
       @property
       def is_cybersecure(self) -> bool:
           """True if detected by Cybersecure (Proofpoint ET PRO) signature."""
           return ET_PRO_SID_MIN <= self.signature_id <= ET_PRO_SID_MAX

    Note: Use pydantic computed_field (not @property alone) so it serializes to JSON/dict
  </implementation>
</feature>

<verification>
```bash
# Run specific tests
pytest tests/test_ips_models.py -v -k "cybersecure"

# Run all IPS model tests to ensure no regressions
pytest tests/test_ips_models.py -v
```
</verification>

<success_criteria>
- [ ] ET_PRO_SID_MIN and ET_PRO_SID_MAX constants defined
- [ ] IPSEvent has is_cybersecure computed_field
- [ ] Tests pass for boundary cases (min, max, just below, just above)
- [ ] Tests pass for typical ET Open signatures
- [ ] All existing IPS model tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-cybersecure-integration/12-01-SUMMARY.md`
</output>
