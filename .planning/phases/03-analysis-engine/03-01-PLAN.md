---
phase: 03-analysis-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/unifi_scanner/analysis/__init__.py
  - src/unifi_scanner/analysis/engine.py
  - src/unifi_scanner/analysis/rules/__init__.py
  - src/unifi_scanner/analysis/rules/base.py
  - src/unifi_scanner/models/enums.py
  - tests/test_analysis_engine.py
autonomous: true

must_haves:
  truths:
    - "Analysis engine accepts LogEntry objects and produces Finding objects"
    - "Unknown event types are captured gracefully without exceptions"
    - "Rules can be registered and dispatched based on event_type"
    - "Rule definitions specify category, severity, and template placeholders"
  artifacts:
    - path: "src/unifi_scanner/analysis/engine.py"
      provides: "Main AnalysisEngine class with rule dispatch"
      exports: ["AnalysisEngine"]
    - path: "src/unifi_scanner/analysis/rules/base.py"
      provides: "Rule protocol and dataclass definitions"
      exports: ["Rule", "RuleRegistry"]
    - path: "src/unifi_scanner/models/enums.py"
      provides: "Updated enums with UNCATEGORIZED category"
      contains: "UNCATEGORIZED"
  key_links:
    - from: "src/unifi_scanner/analysis/engine.py"
      to: "src/unifi_scanner/analysis/rules/base.py"
      via: "RuleRegistry for event_type dispatch"
      pattern: "RuleRegistry"
    - from: "src/unifi_scanner/analysis/engine.py"
      to: "src/unifi_scanner/models/finding.py"
      via: "Creates Finding objects from matched rules"
      pattern: "Finding\\("
---

<objective>
Create the analysis engine architecture with rule registration and dictionary dispatch.

Purpose: This is the foundational architecture for the analysis system. The engine processes LogEntry objects, dispatches to registered rules based on event_type, and produces Finding objects. Unknown event types are handled gracefully by routing to an "Uncategorized" bucket per user decision.

Output: AnalysisEngine class, Rule dataclass, RuleRegistry for dispatch, and tests verifying core flow.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-analysis-engine/03-CONTEXT.md
@.planning/phases/03-analysis-engine/03-RESEARCH.md

# Key existing files
@src/unifi_scanner/models/log_entry.py
@src/unifi_scanner/models/finding.py
@src/unifi_scanner/models/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UNCATEGORIZED category and update enums</name>
  <files>src/unifi_scanner/models/enums.py</files>
  <action>
Update the Category enum to include UNCATEGORIZED for unknown event types:

1. Add `UNCATEGORIZED = "uncategorized"` to the Category enum after SYSTEM.

This aligns with user decision: "Unknown patterns: Put in separate 'Uncategorized' bucket - don't assign a severity level"

The enum after update should be:
```python
class Category(str, Enum):
    """Category of finding or log entry."""
    SECURITY = "security"
    CONNECTIVITY = "connectivity"
    PERFORMANCE = "performance"
    SYSTEM = "system"
    UNCATEGORIZED = "uncategorized"
```
  </action>
  <verify>
Run: `python -c "from unifi_scanner.models.enums import Category; print(Category.UNCATEGORIZED.value)"`
Should print: `uncategorized`
  </verify>
  <done>
Category enum includes UNCATEGORIZED for handling unknown event types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Rule dataclass and RuleRegistry</name>
  <files>
src/unifi_scanner/analysis/__init__.py
src/unifi_scanner/analysis/rules/__init__.py
src/unifi_scanner/analysis/rules/base.py
  </files>
  <action>
1. Create `src/unifi_scanner/analysis/` directory.

2. Create `src/unifi_scanner/analysis/__init__.py`:
   - Leave as placeholder (will export AnalysisEngine after Task 3)

3. Create `src/unifi_scanner/analysis/rules/` directory.

4. Create `src/unifi_scanner/analysis/rules/__init__.py`:
   - Export Rule, RuleRegistry from base

5. Create `src/unifi_scanner/analysis/rules/base.py`:

```python
"""Base rule definitions and registry for analysis engine."""

from dataclasses import dataclass, field
from typing import Callable, Dict, List, Optional, Pattern
import re

from unifi_scanner.models.enums import Category, Severity


@dataclass
class Rule:
    """Definition of a single analysis rule.

    Rules match LogEntry objects based on event_type and optional
    message pattern, then provide category, severity, and templates
    for generating findings.

    Attributes:
        name: Human-readable rule name for debugging
        event_types: List of event types this rule handles
        category: Finding category (Security, Connectivity, etc.)
        severity: Finding severity (low, medium, severe)
        title_template: Template for finding title with {placeholders}
        description_template: Plain English explanation with {placeholders}
        remediation_template: Step-by-step fix (SEVERE/MEDIUM only, None for LOW)
        pattern: Optional regex for additional message matching
    """
    name: str
    event_types: List[str]
    category: Category
    severity: Severity
    title_template: str
    description_template: str
    remediation_template: Optional[str] = None
    pattern: Optional[Pattern] = field(default=None, repr=False)

    def __post_init__(self):
        """Compile pattern string to regex if needed."""
        if isinstance(self.pattern, str):
            self.pattern = re.compile(self.pattern)

    def matches(self, event_type: str, message: str) -> bool:
        """Check if this rule applies to the given event.

        Args:
            event_type: The event_type from LogEntry
            message: The message from LogEntry

        Returns:
            True if rule matches (event_type in list AND pattern matches if set)
        """
        if event_type not in self.event_types:
            return False
        if self.pattern and not self.pattern.search(message):
            return False
        return True


class RuleRegistry:
    """Registry of rules with dictionary dispatch by event_type.

    Provides O(1) lookup of rules by event_type, with support for
    multiple rules per event_type and unknown event handling.
    """

    def __init__(self):
        self._rules: List[Rule] = []
        # Index: event_type -> list of rules that handle it
        self._index: Dict[str, List[Rule]] = {}

    def register(self, rule: Rule) -> None:
        """Register a rule in the registry.

        Args:
            rule: Rule instance to register
        """
        self._rules.append(rule)
        for event_type in rule.event_types:
            if event_type not in self._index:
                self._index[event_type] = []
            self._index[event_type].append(rule)

    def get_rules(self, event_type: str) -> List[Rule]:
        """Get all rules that might handle an event_type.

        Args:
            event_type: The event_type to look up

        Returns:
            List of matching Rule objects (empty if unknown event_type)
        """
        return self._index.get(event_type, [])

    def find_matching_rule(self, event_type: str, message: str) -> Optional[Rule]:
        """Find the first rule that matches event_type and message.

        Args:
            event_type: The event_type from LogEntry
            message: The message from LogEntry

        Returns:
            First matching Rule, or None if no match
        """
        for rule in self.get_rules(event_type):
            if rule.matches(event_type, message):
                return rule
        return None

    def is_known_event_type(self, event_type: str) -> bool:
        """Check if event_type has any registered rules.

        Args:
            event_type: The event_type to check

        Returns:
            True if at least one rule handles this event_type
        """
        return event_type in self._index

    @property
    def all_rules(self) -> List[Rule]:
        """Get all registered rules."""
        return list(self._rules)

    @property
    def known_event_types(self) -> List[str]:
        """Get all known event types."""
        return list(self._index.keys())
```
  </action>
  <verify>
Run: `python -c "from unifi_scanner.analysis.rules import Rule, RuleRegistry; from unifi_scanner.models.enums import Category, Severity; r = Rule(name='test', event_types=['EVT_TEST'], category=Category.SYSTEM, severity=Severity.LOW, title_template='Test', description_template='Desc'); reg = RuleRegistry(); reg.register(r); print(reg.is_known_event_type('EVT_TEST'), reg.is_known_event_type('UNKNOWN'))"`
Should print: `True False`
  </verify>
  <done>
Rule dataclass defines rule structure with event_types, category, severity, and templates. RuleRegistry provides O(1) event_type lookup with dictionary dispatch.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AnalysisEngine with rule dispatch and tests</name>
  <files>
src/unifi_scanner/analysis/__init__.py
src/unifi_scanner/analysis/engine.py
tests/test_analysis_engine.py
  </files>
  <action>
1. Create `src/unifi_scanner/analysis/engine.py`:

```python
"""Main analysis engine for processing UniFi logs."""

from typing import Dict, List, Optional, Any

import structlog

from unifi_scanner.models.enums import Category, Severity
from unifi_scanner.models.finding import Finding
from unifi_scanner.models.log_entry import LogEntry
from unifi_scanner.analysis.rules.base import Rule, RuleRegistry

logger = structlog.get_logger(__name__)


class AnalysisEngine:
    """Engine for analyzing LogEntry objects and producing Findings.

    Uses a RuleRegistry for dictionary dispatch based on event_type.
    Unknown event types are captured gracefully in the UNCATEGORIZED bucket.

    Usage:
        engine = AnalysisEngine()
        engine.register_rules(my_rules)
        findings = engine.analyze(log_entries)
    """

    def __init__(self, registry: Optional[RuleRegistry] = None):
        """Initialize the analysis engine.

        Args:
            registry: Optional pre-configured RuleRegistry.
                     Creates empty one if not provided.
        """
        self._registry = registry or RuleRegistry()
        self._unknown_event_types: Dict[str, int] = {}

    @property
    def registry(self) -> RuleRegistry:
        """Get the rule registry."""
        return self._registry

    @property
    def unknown_event_types(self) -> Dict[str, int]:
        """Get counts of unknown event types encountered."""
        return dict(self._unknown_event_types)

    def register_rule(self, rule: Rule) -> None:
        """Register a single rule.

        Args:
            rule: Rule to register
        """
        self._registry.register(rule)
        logger.debug("rule_registered", rule_name=rule.name, event_types=rule.event_types)

    def register_rules(self, rules: List[Rule]) -> None:
        """Register multiple rules.

        Args:
            rules: List of rules to register
        """
        for rule in rules:
            self.register_rule(rule)
        logger.info("rules_registered", count=len(rules))

    def analyze_entry(self, entry: LogEntry) -> Optional[Finding]:
        """Analyze a single log entry.

        Args:
            entry: LogEntry to analyze

        Returns:
            Finding if a rule matched, None for unmatched entries.
            Unknown event types are tracked but don't produce findings
            (they go in the UNCATEGORIZED bucket which is logged separately).
        """
        rule = self._registry.find_matching_rule(entry.event_type, entry.message)

        if rule is None:
            # Track unknown event type
            if not self._registry.is_known_event_type(entry.event_type):
                self._unknown_event_types[entry.event_type] = (
                    self._unknown_event_types.get(entry.event_type, 0) + 1
                )
                logger.debug(
                    "unknown_event_type",
                    event_type=entry.event_type,
                    count=self._unknown_event_types[entry.event_type],
                )
            return None

        # Create finding from rule template
        finding = self._create_finding(entry, rule)
        return finding

    def analyze(self, entries: List[LogEntry]) -> List[Finding]:
        """Analyze multiple log entries.

        Args:
            entries: List of LogEntry objects to analyze

        Returns:
            List of Finding objects (one per matched entry).
            Note: This does NOT deduplicate - use FindingStore for that.
        """
        findings = []
        for entry in entries:
            finding = self.analyze_entry(entry)
            if finding:
                findings.append(finding)

        logger.info(
            "analysis_complete",
            entries_processed=len(entries),
            findings_created=len(findings),
            unknown_types=len(self._unknown_event_types),
        )
        return findings

    def _create_finding(self, entry: LogEntry, rule: Rule) -> Finding:
        """Create a Finding from a LogEntry and matched Rule.

        Args:
            entry: The source LogEntry
            rule: The matched Rule with templates

        Returns:
            Finding with rendered templates
        """
        # Build template context from entry
        context = self._build_template_context(entry)

        # Render templates with safe formatting
        title = self._safe_format(rule.title_template, context)
        description = self._safe_format(rule.description_template, context)
        remediation = None
        if rule.remediation_template and rule.severity in (Severity.SEVERE, Severity.MEDIUM):
            remediation = self._safe_format(rule.remediation_template, context)

        return Finding(
            severity=rule.severity,
            category=rule.category,
            title=title,
            description=description,
            remediation=remediation,
            source_log_ids=[entry.id],
            first_seen=entry.timestamp,
            last_seen=entry.timestamp,
            device_mac=entry.device_mac,
            device_name=entry.device_name,
            metadata={
                "rule_name": rule.name,
                "event_type": entry.event_type,
            },
        )

    def _build_template_context(self, entry: LogEntry) -> Dict[str, Any]:
        """Build context dictionary for template rendering.

        Args:
            entry: LogEntry to extract context from

        Returns:
            Dict with common placeholders populated
        """
        # Device name with MAC fallback per user decision
        device_display = entry.device_name or entry.device_mac or "Unknown device"

        context = {
            "device_name": device_display,
            "device_mac": entry.device_mac or "Unknown",
            "event_type": entry.event_type,
            "message": entry.message,
            "timestamp": entry.timestamp.strftime("%Y-%m-%d %H:%M:%S UTC"),
        }

        # Extract common fields from raw_data
        raw = entry.raw_data or {}
        context["ip"] = raw.get("ip", raw.get("client_ip", raw.get("src_ip", "Unknown")))
        context["user"] = raw.get("admin", raw.get("user", raw.get("username", "Unknown")))
        context["subsystem"] = raw.get("subsystem", entry.metadata.get("subsystem", "Unknown"))

        return context

    def _safe_format(self, template: str, context: Dict[str, Any]) -> str:
        """Safely format a template string with context.

        Missing keys are replaced with 'Unknown' instead of raising KeyError.

        Args:
            template: Template string with {placeholders}
            context: Dictionary of values

        Returns:
            Formatted string with placeholders replaced
        """
        # Use defaultdict-like behavior for missing keys
        class SafeDict(dict):
            def __missing__(self, key):
                logger.debug("template_missing_key", key=key)
                return "Unknown"

        safe_context = SafeDict(context)
        try:
            return template.format_map(safe_context)
        except Exception as e:
            logger.warning("template_format_error", template=template[:50], error=str(e))
            return template

    def clear_unknown_counts(self) -> None:
        """Clear the unknown event type counts."""
        self._unknown_event_types.clear()
```

2. Update `src/unifi_scanner/analysis/__init__.py`:
```python
"""Analysis engine for UniFi log processing."""

from unifi_scanner.analysis.engine import AnalysisEngine
from unifi_scanner.analysis.rules import Rule, RuleRegistry

__all__ = ["AnalysisEngine", "Rule", "RuleRegistry"]
```

3. Create `tests/test_analysis_engine.py`:

```python
"""Tests for the analysis engine."""

import pytest
from datetime import datetime, timezone
from uuid import uuid4

from unifi_scanner.analysis import AnalysisEngine, Rule, RuleRegistry
from unifi_scanner.models.enums import Category, Severity, LogSource
from unifi_scanner.models.log_entry import LogEntry
from unifi_scanner.models.finding import Finding


@pytest.fixture
def sample_rule():
    """Create a sample rule for testing."""
    return Rule(
        name="test_failed_login",
        event_types=["EVT_AD_LOGIN_FAILED"],
        category=Category.SECURITY,
        severity=Severity.SEVERE,
        title_template="[Security] Failed login from {ip}",
        description_template=(
            "Someone attempted to log into your UniFi controller from {ip} "
            "but failed authentication ({event_type}). This could indicate "
            "someone trying to guess your password."
        ),
        remediation_template=(
            "1. Check if you recognize the IP address {ip}\n"
            "2. Consider blocking this IP in your firewall"
        ),
    )


@pytest.fixture
def sample_log_entry():
    """Create a sample log entry for testing."""
    return LogEntry(
        timestamp=datetime(2024, 1, 15, 10, 30, 0, tzinfo=timezone.utc),
        source=LogSource.API,
        event_type="EVT_AD_LOGIN_FAILED",
        message="Admin login failed",
        device_name="UDM-Pro",
        raw_data={"ip": "192.168.1.100", "admin": "admin"},
    )


@pytest.fixture
def engine(sample_rule):
    """Create an engine with sample rule registered."""
    engine = AnalysisEngine()
    engine.register_rule(sample_rule)
    return engine


class TestRuleRegistry:
    """Tests for RuleRegistry."""

    def test_register_and_lookup(self, sample_rule):
        """Test rule registration and lookup."""
        registry = RuleRegistry()
        registry.register(sample_rule)

        assert registry.is_known_event_type("EVT_AD_LOGIN_FAILED")
        assert not registry.is_known_event_type("EVT_UNKNOWN")

    def test_find_matching_rule(self, sample_rule):
        """Test finding matching rule."""
        registry = RuleRegistry()
        registry.register(sample_rule)

        rule = registry.find_matching_rule("EVT_AD_LOGIN_FAILED", "any message")
        assert rule is not None
        assert rule.name == "test_failed_login"

    def test_find_no_match(self, sample_rule):
        """Test no match for unknown event."""
        registry = RuleRegistry()
        registry.register(sample_rule)

        rule = registry.find_matching_rule("EVT_UNKNOWN", "any message")
        assert rule is None

    def test_pattern_matching(self):
        """Test rule with regex pattern."""
        rule = Rule(
            name="high_cpu",
            event_types=["EVT_AP_ALERT"],
            category=Category.PERFORMANCE,
            severity=Severity.MEDIUM,
            title_template="High CPU on {device_name}",
            description_template="CPU usage exceeded threshold",
            pattern=r"CPU.*\d+%",
        )
        registry = RuleRegistry()
        registry.register(rule)

        # Should match with pattern
        match = registry.find_matching_rule("EVT_AP_ALERT", "CPU usage at 95%")
        assert match is not None

        # Should not match without pattern
        no_match = registry.find_matching_rule("EVT_AP_ALERT", "Memory usage high")
        assert no_match is None


class TestAnalysisEngine:
    """Tests for AnalysisEngine."""

    def test_analyze_entry_creates_finding(self, engine, sample_log_entry):
        """Test that matching entry creates finding."""
        finding = engine.analyze_entry(sample_log_entry)

        assert finding is not None
        assert finding.severity == Severity.SEVERE
        assert finding.category == Category.SECURITY
        assert "192.168.1.100" in finding.title
        assert finding.remediation is not None
        assert sample_log_entry.id in finding.source_log_ids

    def test_analyze_entry_unknown_type(self, engine):
        """Test that unknown event type is tracked but returns None."""
        entry = LogEntry(
            timestamp=datetime.now(timezone.utc),
            source=LogSource.API,
            event_type="EVT_UNKNOWN_NEW",
            message="Something new",
        )

        finding = engine.analyze_entry(entry)

        assert finding is None
        assert "EVT_UNKNOWN_NEW" in engine.unknown_event_types
        assert engine.unknown_event_types["EVT_UNKNOWN_NEW"] == 1

    def test_analyze_multiple_entries(self, engine, sample_log_entry):
        """Test analyzing multiple entries."""
        entries = [sample_log_entry, sample_log_entry]
        findings = engine.analyze(entries)

        assert len(findings) == 2

    def test_template_rendering_with_missing_key(self, engine):
        """Test template renders gracefully with missing key."""
        # Create entry without ip in raw_data
        entry = LogEntry(
            timestamp=datetime.now(timezone.utc),
            source=LogSource.API,
            event_type="EVT_AD_LOGIN_FAILED",
            message="Login failed",
            raw_data={},  # No ip key
        )

        finding = engine.analyze_entry(entry)

        assert finding is not None
        assert "Unknown" in finding.title  # {ip} replaced with Unknown

    def test_device_name_fallback_to_mac(self, engine):
        """Test device name falls back to MAC address."""
        entry = LogEntry(
            timestamp=datetime.now(timezone.utc),
            source=LogSource.API,
            event_type="EVT_AD_LOGIN_FAILED",
            message="Login failed",
            device_mac="aa:bb:cc:dd:ee:ff",
            device_name=None,
            raw_data={"ip": "10.0.0.1"},
        )

        finding = engine.analyze_entry(entry)

        # Context should use MAC as device_name
        assert finding.device_mac == "aa:bb:cc:dd:ee:ff"

    def test_remediation_only_for_severe_and_medium(self):
        """Test that LOW severity rules don't get remediation."""
        low_rule = Rule(
            name="admin_login",
            event_types=["EVT_AD_Login"],
            category=Category.SYSTEM,
            severity=Severity.LOW,
            title_template="Admin login",
            description_template="An admin logged in",
            remediation_template="This should not appear",  # Has template but LOW severity
        )

        engine = AnalysisEngine()
        engine.register_rule(low_rule)

        entry = LogEntry(
            timestamp=datetime.now(timezone.utc),
            source=LogSource.API,
            event_type="EVT_AD_Login",
            message="Admin login",
        )

        finding = engine.analyze_entry(entry)

        assert finding is not None
        assert finding.remediation is None  # Should not have remediation for LOW


class TestRuleDefinition:
    """Tests for Rule dataclass."""

    def test_rule_creation(self):
        """Test basic rule creation."""
        rule = Rule(
            name="test",
            event_types=["EVT_A", "EVT_B"],
            category=Category.SECURITY,
            severity=Severity.SEVERE,
            title_template="Title",
            description_template="Description",
        )

        assert rule.name == "test"
        assert len(rule.event_types) == 2
        assert rule.remediation_template is None

    def test_rule_with_string_pattern(self):
        """Test that string pattern gets compiled to regex."""
        rule = Rule(
            name="test",
            event_types=["EVT_A"],
            category=Category.SYSTEM,
            severity=Severity.LOW,
            title_template="Title",
            description_template="Desc",
            pattern=r"\d+",
        )

        assert rule.pattern is not None
        assert rule.pattern.search("test 123") is not None
```
  </action>
  <verify>
Run: `pytest tests/test_analysis_engine.py -v`
All tests should pass.
  </verify>
  <done>
AnalysisEngine accepts LogEntry objects, dispatches to rules via RuleRegistry, produces Finding objects with rendered templates, and gracefully tracks unknown event types.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from unifi_scanner.models.enums import Category; print(Category.UNCATEGORIZED)"` - UNCATEGORIZED enum exists
2. `python -c "from unifi_scanner.analysis import AnalysisEngine, Rule, RuleRegistry; print('imports ok')"` - all imports work
3. `pytest tests/test_analysis_engine.py -v` - all tests pass
4. Manual verification of unknown event handling:
   ```python
   from unifi_scanner.analysis import AnalysisEngine
   from unifi_scanner.models import LogEntry
   from unifi_scanner.models.enums import LogSource
   from datetime import datetime, timezone

   engine = AnalysisEngine()
   entry = LogEntry(timestamp=datetime.now(timezone.utc), source=LogSource.API, event_type="NEW_UNKNOWN", message="test")
   result = engine.analyze_entry(entry)
   print(result is None, engine.unknown_event_types)
   # Should print: True {'NEW_UNKNOWN': 1}
   ```
</verification>

<success_criteria>
- Category enum includes UNCATEGORIZED value
- Rule dataclass captures name, event_types, category, severity, templates, and optional pattern
- RuleRegistry provides O(1) lookup by event_type
- AnalysisEngine.analyze_entry() returns Finding for matched rules, None for unknown
- Unknown event types are tracked in engine.unknown_event_types
- Template rendering handles missing keys gracefully (replaces with "Unknown")
- Device name falls back to MAC address when name is None
- Remediation is only included for SEVERE and MEDIUM severity findings
- Tests cover core functionality and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/03-analysis-engine/03-01-SUMMARY.md`
</output>
