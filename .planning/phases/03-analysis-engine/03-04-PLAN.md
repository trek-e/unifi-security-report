---
phase: 03-analysis-engine
plan: 04
type: execute
wave: 2
depends_on: ["03-01", "03-03"]
files_modified:
  - src/unifi_scanner/analysis/templates/__init__.py
  - src/unifi_scanner/analysis/templates/explanations.py
  - src/unifi_scanner/analysis/templates/remediation.py
  - src/unifi_scanner/analysis/formatter.py
  - src/unifi_scanner/analysis/__init__.py
  - tests/test_templates.py
autonomous: true

must_haves:
  truths:
    - "Explanations include what happened AND why it matters"
    - "Device names are used when available, MAC address as fallback"
    - "Event type is included in parentheses for Googling"
    - "Absolute timestamps are shown (not relative time)"
    - "Category prefix is visible in finding display"
    - "SEVERE remediation has numbered step-by-step instructions"
    - "MEDIUM remediation has high-level guidance"
    - "LOW findings have no remediation"
  artifacts:
    - path: "src/unifi_scanner/analysis/templates/explanations.py"
      provides: "Explanation template strings and helpers"
      exports: ["EXPLANATION_TEMPLATES", "render_explanation"]
    - path: "src/unifi_scanner/analysis/templates/remediation.py"
      provides: "Remediation template strings"
      exports: ["REMEDIATION_TEMPLATES", "render_remediation"]
    - path: "src/unifi_scanner/analysis/formatter.py"
      provides: "FindingFormatter for display-ready output"
      exports: ["FindingFormatter"]
  key_links:
    - from: "src/unifi_scanner/analysis/formatter.py"
      to: "src/unifi_scanner/analysis/templates/"
      via: "Uses templates to format findings for display"
      pattern: "from.*templates"
    - from: "src/unifi_scanner/analysis/formatter.py"
      to: "src/unifi_scanner/models/finding.py"
      via: "Formats Finding objects"
      pattern: "Finding"
---

<objective>
Create plain English explanation and remediation template system.

Purpose: The analysis engine produces structured findings, but users need human-readable output. This plan creates the template system for rendering findings with: category-prefixed titles, plain English explanations (with event type for Googling), device names (MAC fallback), absolute timestamps, and severity-appropriate remediation guidance.

Output: Template modules with explanation and remediation strings, FindingFormatter for display-ready output, and tests verifying all user style decisions.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-analysis-engine/03-CONTEXT.md
@.planning/phases/03-analysis-engine/03-RESEARCH.md

# From previous plans
@src/unifi_scanner/analysis/engine.py
@src/unifi_scanner/analysis/store.py
@src/unifi_scanner/models/finding.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create explanation and remediation template modules</name>
  <files>
src/unifi_scanner/analysis/templates/__init__.py
src/unifi_scanner/analysis/templates/explanations.py
src/unifi_scanner/analysis/templates/remediation.py
  </files>
  <action>
1. Create `src/unifi_scanner/analysis/templates/` directory.

2. Create `src/unifi_scanner/analysis/templates/__init__.py`:

```python
"""Template system for finding explanations and remediation guidance.

Provides plain English templates following user style decisions:
- Light technical context with impact explanations
- Device names when available, MAC fallback
- Event type in parentheses for searchability
- Category prefix in titles
- Step-by-step remediation for SEVERE, high-level for MEDIUM
"""

from unifi_scanner.analysis.templates.explanations import (
    EXPLANATION_TEMPLATES,
    render_explanation,
    get_explanation_template,
)
from unifi_scanner.analysis.templates.remediation import (
    REMEDIATION_TEMPLATES,
    render_remediation,
    get_remediation_template,
)

__all__ = [
    "EXPLANATION_TEMPLATES",
    "REMEDIATION_TEMPLATES",
    "render_explanation",
    "render_remediation",
    "get_explanation_template",
    "get_remediation_template",
]
```

3. Create `src/unifi_scanner/analysis/templates/explanations.py`:

```python
"""Plain English explanation templates for findings.

Style decisions (from 03-CONTEXT.md):
- Light technical context: uses terms but explains impact
- Include what happened AND why it matters
- Device names when available, MAC address fallback
- Include event type in parentheses for Googling
- Category shown in title prefix
"""

from typing import Any, Dict, Optional

import structlog

logger = structlog.get_logger(__name__)


# Template placeholders:
# {device_name} - Device name or MAC fallback
# {device_mac} - MAC address
# {ip} - IP address
# {event_type} - Original UniFi event type
# {timestamp} - When it happened
# {message} - Original message
# {user} - Admin user if applicable


EXPLANATION_TEMPLATES: Dict[str, Dict[str, str]] = {
    # Security explanations
    "admin_login_failed": {
        "title": "[Security] Failed login attempt from {ip}",
        "description": (
            "Someone attempted to log into your UniFi controller from {ip} but "
            "failed authentication ({event_type}). This could indicate someone "
            "trying to guess your password. If this happens repeatedly, your "
            "controller may be under a brute-force attack."
        ),
    },
    "admin_login_success": {
        "title": "[Security] Admin login from {ip}",
        "description": (
            "An administrator logged into your UniFi controller from {ip} "
            "({event_type}). This is normal if you or a known admin initiated it. "
            "This is logged for your awareness."
        ),
    },
    "rogue_ap_detected": {
        "title": "[Security] Rogue access point detected near {device_name}",
        "description": (
            "Your access point {device_name} detected an unauthorized wireless "
            "network nearby ({event_type}). This could be a neighbor's network, "
            "but could also indicate someone attempting to set up a malicious "
            "hotspot to intercept your traffic."
        ),
    },
    "ips_alert": {
        "title": "[Security] Intrusion detection alert",
        "description": (
            "Your UniFi threat management system detected suspicious network "
            "activity ({event_type}). The intrusion prevention system flagged "
            "traffic that matches known attack patterns. This could indicate "
            "malware on your network or an external attack attempt."
        ),
    },

    # Connectivity explanations
    "ap_lost_contact": {
        "title": "[Connectivity] Lost contact with {device_name}",
        "description": (
            "Your access point {device_name} ({device_mac}) stopped responding "
            "to the controller ({event_type}). Devices connected to this AP have "
            "lost WiFi connectivity in that area. This could be due to power loss, "
            "network cable issues, or hardware failure."
        ),
    },
    "switch_lost_contact": {
        "title": "[Connectivity] Lost contact with switch {device_name}",
        "description": (
            "Your network switch {device_name} ({device_mac}) stopped responding "
            "to the controller ({event_type}). All devices connected to this switch "
            "have lost network connectivity. This affects any APs, computers, or "
            "other equipment plugged into this switch."
        ),
    },
    "gateway_wan_down": {
        "title": "[Connectivity] Internet connection lost",
        "description": (
            "Your gateway's WAN interface went down ({event_type}). This means "
            "your entire network has lost internet connectivity. All devices can "
            "still communicate locally but cannot reach the internet. This could "
            "be an ISP outage or modem issue."
        ),
    },
    "ap_isolated": {
        "title": "[Connectivity] Access point {device_name} isolated from network",
        "description": (
            "Your access point {device_name} has been isolated from the network "
            "({event_type}). The AP can't reach the controller and may have "
            "limited functionality. Wireless clients may experience intermittent "
            "connectivity issues."
        ),
    },
    "device_connected": {
        "title": "[Connectivity] {device_name} connected",
        "description": (
            "Your device {device_name} connected to the controller ({event_type}). "
            "This is normal when a device comes back online after a restart or "
            "when a new device is adopted into your network."
        ),
    },
    "client_activity": {
        "title": "[Connectivity] Client device activity",
        "description": (
            "A client device connected or disconnected from your network "
            "({event_type}). This is normal activity as devices join and leave "
            "your WiFi network throughout the day."
        ),
    },

    # Performance explanations
    "interference_detected": {
        "title": "[Performance] Wireless interference detected on {device_name}",
        "description": (
            "Your access point {device_name} detected possible wireless "
            "interference ({event_type}). This can cause slower WiFi speeds and "
            "connection drops. Common sources include neighboring WiFi networks, "
            "Bluetooth devices, microwaves, and cordless phones."
        ),
    },
    "high_cpu": {
        "title": "[Performance] High CPU usage on {device_name}",
        "description": (
            "Your device {device_name} is experiencing high CPU usage "
            "({event_type}). This can cause slower network performance and "
            "delayed responses. Sustained high CPU may indicate the device is "
            "overloaded or experiencing issues."
        ),
    },
    "high_memory": {
        "title": "[Performance] High memory usage on {device_name}",
        "description": (
            "Your device {device_name} is running low on memory ({event_type}). "
            "This can cause instability and potential crashes. Memory usually "
            "fills up over time and a restart often resolves the issue."
        ),
    },
    "slow_speed": {
        "title": "[Performance] Speed test shows slow internet",
        "description": (
            "A speed test from your gateway showed slower than expected internet "
            "speeds ({event_type}). This could indicate ISP throttling, network "
            "congestion, or connection issues between your gateway and modem."
        ),
    },
    "channel_congestion": {
        "title": "[Performance] High channel utilization on {device_name}",
        "description": (
            "The wireless channel used by {device_name} is congested "
            "({event_type}). This means many devices or neighboring networks are "
            "competing for airtime, which slows down your WiFi."
        ),
    },

    # System explanations
    "firmware_upgraded": {
        "title": "[System] {device_name} firmware updated",
        "description": (
            "Your device {device_name} completed a firmware upgrade "
            "({event_type}). The device may have restarted as part of the update "
            "process. This is normal maintenance activity."
        ),
    },
    "device_restarted": {
        "title": "[System] {device_name} restarted",
        "description": (
            "Your device {device_name} was restarted ({event_type}). If you "
            "initiated this restart, no action is needed. The device is now back "
            "online and functioning normally."
        ),
    },
    "device_restarted_unexpected": {
        "title": "[System] {device_name} restarted unexpectedly",
        "description": (
            "Your device {device_name} restarted for an unknown reason "
            "({event_type}). This could indicate a power fluctuation, firmware "
            "crash, or hardware issue. Occasional unexpected restarts may be "
            "normal, but frequent occurrences warrant investigation."
        ),
    },
    "device_adopted": {
        "title": "[System] New device {device_name} adopted",
        "description": (
            "A new device {device_name} was adopted into your UniFi network "
            "({event_type}). The device is now managed by your controller and "
            "can be configured through the UniFi interface."
        ),
    },
    "config_changed": {
        "title": "[System] Configuration changed by {user}",
        "description": (
            "Network configuration was changed by {user} ({event_type}). This is "
            "logged for your records. Review if you did not make this change "
            "yourself."
        ),
    },
    "backup_created": {
        "title": "[System] Backup created successfully",
        "description": (
            "A backup of your UniFi configuration was created ({event_type}). "
            "Your settings are now saved and can be restored if needed."
        ),
    },
    "update_available": {
        "title": "[System] Firmware update available for {device_name}",
        "description": (
            "A firmware update is available for {device_name} ({event_type}). "
            "Keeping firmware up to date improves security and stability. Updates "
            "can be applied from the UniFi app."
        ),
    },

    # Fallback for unknown events
    "unknown": {
        "title": "[Uncategorized] {event_type}",
        "description": (
            "An event occurred that doesn't match any known patterns "
            "({event_type}). Message: {message}"
        ),
    },
}


def get_explanation_template(rule_name: str) -> Optional[Dict[str, str]]:
    """Get explanation template by rule name.

    Args:
        rule_name: Name of the rule (matches EXPLANATION_TEMPLATES keys)

    Returns:
        Dict with 'title' and 'description' templates, or None if not found
    """
    return EXPLANATION_TEMPLATES.get(rule_name)


def render_explanation(
    template_name: str,
    context: Dict[str, Any],
    fallback: bool = True,
) -> Dict[str, str]:
    """Render an explanation template with context.

    Args:
        template_name: Key in EXPLANATION_TEMPLATES
        context: Dict with placeholder values
        fallback: If True, use 'unknown' template for missing names

    Returns:
        Dict with rendered 'title' and 'description'

    Raises:
        KeyError: If template not found and fallback=False
    """
    template = EXPLANATION_TEMPLATES.get(template_name)

    if template is None:
        if fallback:
            template = EXPLANATION_TEMPLATES["unknown"]
        else:
            raise KeyError(f"No explanation template: {template_name}")

    # Safe formatting with fallback for missing keys
    safe_context = SafeFormatDict(context)

    return {
        "title": template["title"].format_map(safe_context),
        "description": template["description"].format_map(safe_context),
    }


class SafeFormatDict(dict):
    """Dict subclass that returns 'Unknown' for missing keys during format."""

    def __missing__(self, key: str) -> str:
        logger.debug("template_missing_key", key=key)
        return "Unknown"
```

4. Create `src/unifi_scanner/analysis/templates/remediation.py`:

```python
"""Remediation guidance templates for findings.

Style decisions (from 03-CONTEXT.md):
- SEVERE: Step-by-step numbered instructions
- MEDIUM: High-level guidance
- LOW: No remediation (not applicable)
- Assume user can handle it - no escalation suggestions
"""

from typing import Any, Dict, Optional

import structlog

from unifi_scanner.models.enums import Severity

logger = structlog.get_logger(__name__)


# Remediation templates by rule name
# SEVERE rules get detailed step-by-step instructions
# MEDIUM rules get high-level guidance
REMEDIATION_TEMPLATES: Dict[str, str] = {
    # Security (SEVERE)
    "admin_login_failed": (
        "1. Check if you recognize the IP address {ip}\n"
        "2. If unfamiliar, consider blocking it in your firewall\n"
        "3. Ensure your admin password is strong and unique\n"
        "4. Enable two-factor authentication if available in your UniFi setup\n"
        "5. Review Settings > System > Admin in your UniFi controller"
    ),
    "rogue_ap_detected": (
        "1. Open the UniFi app and go to Insights > WiFi\n"
        "2. Look for unknown SSIDs broadcasting near your network\n"
        "3. If the SSID looks suspicious (similar to yours), investigate further\n"
        "4. Consider enabling SSID hiding if you don't need discovery\n"
        "5. Check if any unauthorized devices were connected to your network"
    ),
    "ips_alert": (
        "1. Open UniFi and go to Insights > Threat Management\n"
        "2. Review the specific alert details and source/destination IPs\n"
        "3. If the source is an internal device, scan it for malware\n"
        "4. If the source is external, the traffic was likely blocked\n"
        "5. Consider temporarily isolating affected devices if threat is active"
    ),

    # Connectivity (SEVERE)
    "ap_lost_contact": (
        "1. Check if the access point has power (LED should be lit)\n"
        "2. Verify the ethernet cable is connected at both ends\n"
        "3. Try power cycling the AP by unplugging for 10 seconds\n"
        "4. Check your switch port for errors or PoE budget issues\n"
        "5. If using PoE, ensure your switch can provide enough power"
    ),
    "switch_lost_contact": (
        "1. Check if the switch has power (LEDs should be lit)\n"
        "2. Verify the uplink cable to your router/gateway is secure\n"
        "3. Try power cycling the switch by unplugging for 10 seconds\n"
        "4. Check if other devices on the same circuit lost power\n"
        "5. If the switch is warm/hot, let it cool before restarting"
    ),
    "gateway_wan_down": (
        "1. Check if your modem/ONT has power and shows online status\n"
        "2. Try power cycling your modem (unplug 30 seconds, replug)\n"
        "3. Check your ISP's status page for reported outages\n"
        "4. Verify the cable between modem and UniFi gateway is secure\n"
        "5. If using PPPoE, verify your ISP credentials haven't changed"
    ),
    "ap_isolated": (
        "1. Check the ethernet cable connecting the AP to your switch\n"
        "2. Verify the switch port isn't disabled or in an error state\n"
        "3. Check for VLAN misconfigurations if using VLANs\n"
        "4. Try moving the AP to a different switch port\n"
        "5. Power cycle the AP if cable and port look good"
    ),

    # Performance (MEDIUM - high-level guidance)
    "interference_detected": (
        "Try changing the WiFi channel in Settings > WiFi > Advanced. "
        "Enable automatic channel selection if not already on. "
        "Move the AP away from known interference sources like microwaves or "
        "Bluetooth devices. Consider using 5GHz band for less interference."
    ),
    "high_cpu": (
        "Check how many clients are connected to this device. "
        "Look for any bandwidth-heavy applications running. "
        "Try restarting the device if issue persists. "
        "Check if firmware is up to date."
    ),
    "high_memory": (
        "Try restarting the device to clear memory. "
        "Check if firmware is up to date (updates often fix memory leaks). "
        "If recurring, consider reducing connected clients or features."
    ),
    "slow_speed": (
        "Run a speed test from your ISP's website to compare. "
        "Try power cycling your modem and gateway. "
        "Check for other devices using heavy bandwidth. "
        "Contact your ISP if speeds are consistently below plan."
    ),
    "channel_congestion": (
        "Enable automatic channel selection in WiFi settings. "
        "Consider switching to 5GHz or 6GHz if devices support it. "
        "Reduce the number of SSIDs if you have many configured. "
        "Stagger channel widths across APs."
    ),

    # System (MEDIUM)
    "device_restarted_unexpected": (
        "Check if there were any power outages in your area. "
        "Verify the power source is stable (try different outlet/PoE port). "
        "Check if firmware is up to date. "
        "Monitor for repeated occurrences over the next few days."
    ),
}


def get_remediation_template(rule_name: str) -> Optional[str]:
    """Get remediation template by rule name.

    Args:
        rule_name: Name of the rule

    Returns:
        Remediation template string, or None if not applicable
    """
    return REMEDIATION_TEMPLATES.get(rule_name)


def render_remediation(
    rule_name: str,
    severity: Severity,
    context: Dict[str, Any],
) -> Optional[str]:
    """Render remediation guidance for a finding.

    Per user decision:
    - SEVERE: Full step-by-step instructions
    - MEDIUM: High-level guidance
    - LOW: None (no remediation needed)

    Args:
        rule_name: Name of the rule
        severity: Severity of the finding
        context: Dict with placeholder values

    Returns:
        Rendered remediation string, or None for LOW severity
    """
    # LOW severity findings don't get remediation
    if severity == Severity.LOW:
        return None

    template = REMEDIATION_TEMPLATES.get(rule_name)
    if template is None:
        logger.debug("no_remediation_template", rule_name=rule_name)
        return None

    # Safe formatting
    safe_context = SafeFormatDict(context)
    return template.format_map(safe_context)


class SafeFormatDict(dict):
    """Dict subclass that returns 'Unknown' for missing keys during format."""

    def __missing__(self, key: str) -> str:
        return "Unknown"
```
  </action>
  <verify>
Run: `python -c "from unifi_scanner.analysis.templates import EXPLANATION_TEMPLATES, REMEDIATION_TEMPLATES; print(f'{len(EXPLANATION_TEMPLATES)} explanations, {len(REMEDIATION_TEMPLATES)} remediations')"`
Should print counts showing templates loaded.
  </verify>
  <done>
Explanation templates include category prefix, event type in parentheses, and impact explanations. Remediation templates have step-by-step for SEVERE, high-level for MEDIUM.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FindingFormatter for display-ready output</name>
  <files>
src/unifi_scanner/analysis/formatter.py
src/unifi_scanner/analysis/__init__.py
  </files>
  <action>
1. Create `src/unifi_scanner/analysis/formatter.py`:

```python
"""Formatter for converting findings to display-ready output.

Applies user style decisions:
- Absolute timestamps (not relative)
- Controller timezone for display (configurable)
- Category prefix visible
- Occurrence summary with first/last times
- Recurring issue flag
"""

from datetime import datetime, timezone
from typing import Any, Dict, List, Optional
from zoneinfo import ZoneInfo

import structlog

from unifi_scanner.models.finding import Finding
from unifi_scanner.models.enums import Severity

logger = structlog.get_logger(__name__)


class FindingFormatter:
    """Formats Finding objects for human-readable display.

    Handles timezone conversion, occurrence summaries, and
    structures output for report generation.

    Usage:
        formatter = FindingFormatter(display_timezone="America/New_York")
        formatted = formatter.format_finding(finding)
        print(formatted['title'])
        print(formatted['description'])
        print(formatted['occurrence_summary'])
    """

    DEFAULT_TIME_FORMAT = "%Y-%m-%d %I:%M %p"
    DEFAULT_TIMEZONE = "UTC"

    def __init__(
        self,
        display_timezone: str = DEFAULT_TIMEZONE,
        time_format: str = DEFAULT_TIME_FORMAT,
    ):
        """Initialize the formatter.

        Args:
            display_timezone: Timezone for displaying timestamps
                            (e.g., "America/New_York", "Europe/London")
            time_format: strftime format for timestamps
        """
        self._timezone_str = display_timezone
        self._time_format = time_format

        try:
            self._timezone = ZoneInfo(display_timezone)
        except Exception as e:
            logger.warning(
                "invalid_timezone",
                timezone=display_timezone,
                error=str(e),
                using="UTC",
            )
            self._timezone = timezone.utc
            self._timezone_str = "UTC"

    @property
    def display_timezone(self) -> str:
        """Get the display timezone name."""
        return self._timezone_str

    def format_timestamp(self, dt: datetime) -> str:
        """Format a datetime for display.

        Converts to display timezone and formats per style.

        Args:
            dt: Datetime to format (should be UTC)

        Returns:
            Formatted timestamp string with timezone indicator
        """
        # Convert to display timezone
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        local_dt = dt.astimezone(self._timezone)

        # Format with timezone abbreviation
        formatted = local_dt.strftime(self._time_format)
        tz_abbrev = local_dt.strftime("%Z") or self._timezone_str
        return f"{formatted} {tz_abbrev}"

    def format_occurrence_summary(self, finding: Finding) -> str:
        """Format the occurrence summary for display.

        Per user decision: "Occurred 5 times (first: 2:00 PM, last: 4:30 PM)"

        Args:
            finding: Finding to summarize

        Returns:
            Formatted occurrence summary
        """
        first_str = self.format_timestamp(finding.first_seen)
        last_str = self.format_timestamp(finding.last_seen)

        if finding.occurrence_count == 1:
            return f"Occurred at {first_str}"

        summary = (
            f"Occurred {finding.occurrence_count} times "
            f"(first: {first_str}, last: {last_str})"
        )

        if finding.is_recurring:
            summary = f"[Recurring Issue] {summary}"

        return summary

    def format_finding(self, finding: Finding) -> Dict[str, Any]:
        """Format a single finding for display.

        Args:
            finding: Finding to format

        Returns:
            Dict with formatted fields ready for display/template
        """
        return {
            "id": str(finding.id),
            "severity": finding.severity.value,
            "severity_upper": finding.severity.value.upper(),
            "category": finding.category.value,
            "category_title": finding.category.value.title(),
            "title": finding.title,
            "description": finding.description,
            "remediation": finding.remediation,
            "has_remediation": finding.remediation is not None,
            "device_name": finding.device_name or finding.device_mac or "Unknown",
            "device_mac": finding.device_mac or "Unknown",
            "first_seen": self.format_timestamp(finding.first_seen),
            "last_seen": self.format_timestamp(finding.last_seen),
            "occurrence_count": finding.occurrence_count,
            "occurrence_summary": self.format_occurrence_summary(finding),
            "is_recurring": finding.is_recurring,
            "is_actionable": finding.is_actionable,
            "metadata": finding.metadata,
        }

    def format_findings(self, findings: List[Finding]) -> List[Dict[str, Any]]:
        """Format multiple findings for display.

        Args:
            findings: List of findings to format

        Returns:
            List of formatted finding dicts
        """
        return [self.format_finding(f) for f in findings]

    def format_grouped_findings(
        self, findings: List[Finding]
    ) -> Dict[str, List[Dict[str, Any]]]:
        """Format findings grouped by severity.

        Sorts with SEVERE first, then MEDIUM, then LOW per user preference.

        Args:
            findings: List of findings to format

        Returns:
            Dict with severity keys and lists of formatted findings
        """
        # Sort by severity (SEVERE first)
        severity_order = {
            Severity.SEVERE: 0,
            Severity.MEDIUM: 1,
            Severity.LOW: 2,
        }
        sorted_findings = sorted(
            findings, key=lambda f: severity_order.get(f.severity, 99)
        )

        grouped = {
            "severe": [],
            "medium": [],
            "low": [],
        }

        for finding in sorted_findings:
            formatted = self.format_finding(finding)
            grouped[finding.severity.value].append(formatted)

        return grouped

    def format_text_report(self, findings: List[Finding]) -> str:
        """Format findings as plain text report.

        Args:
            findings: List of findings

        Returns:
            Plain text report string
        """
        if not findings:
            return "No issues found."

        lines = []
        grouped = self.format_grouped_findings(findings)

        # Summary
        total = len(findings)
        severe_count = len(grouped["severe"])
        medium_count = len(grouped["medium"])
        low_count = len(grouped["low"])

        lines.append("=" * 60)
        lines.append("UNIFI NETWORK REPORT")
        lines.append("=" * 60)
        lines.append("")
        lines.append(f"Total Findings: {total}")
        lines.append(f"  - SEVERE: {severe_count}")
        lines.append(f"  - MEDIUM: {medium_count}")
        lines.append(f"  - LOW: {low_count}")
        lines.append("")

        # Severe findings first
        if grouped["severe"]:
            lines.append("-" * 60)
            lines.append("SEVERE ISSUES (require immediate attention)")
            lines.append("-" * 60)
            for f in grouped["severe"]:
                lines.extend(self._format_finding_text(f))
            lines.append("")

        # Medium findings
        if grouped["medium"]:
            lines.append("-" * 60)
            lines.append("MEDIUM ISSUES (worth monitoring)")
            lines.append("-" * 60)
            for f in grouped["medium"]:
                lines.extend(self._format_finding_text(f))
            lines.append("")

        # Low findings
        if grouped["low"]:
            lines.append("-" * 60)
            lines.append("LOW (informational)")
            lines.append("-" * 60)
            for f in grouped["low"]:
                lines.extend(self._format_finding_text(f, include_remediation=False))
            lines.append("")

        lines.append("=" * 60)
        lines.append(f"Report generated: {self.format_timestamp(datetime.now(timezone.utc))}")
        lines.append("=" * 60)

        return "\n".join(lines)

    def _format_finding_text(
        self, formatted: Dict[str, Any], include_remediation: bool = True
    ) -> List[str]:
        """Format a single finding as text lines.

        Args:
            formatted: Formatted finding dict
            include_remediation: Whether to include remediation

        Returns:
            List of text lines
        """
        lines = []
        lines.append("")
        lines.append(f"  {formatted['title']}")
        lines.append(f"  {formatted['occurrence_summary']}")
        lines.append("")
        lines.append(f"  {formatted['description']}")

        if include_remediation and formatted["has_remediation"]:
            lines.append("")
            lines.append("  What to do:")
            # Indent remediation steps
            for line in formatted["remediation"].split("\n"):
                lines.append(f"    {line}")

        lines.append("")
        return lines
```

2. Update `src/unifi_scanner/analysis/__init__.py`:

```python
"""Analysis engine for UniFi log processing."""

from unifi_scanner.analysis.engine import AnalysisEngine
from unifi_scanner.analysis.rules import Rule, RuleRegistry
from unifi_scanner.analysis.store import FindingStore
from unifi_scanner.analysis.formatter import FindingFormatter

__all__ = [
    "AnalysisEngine",
    "Rule",
    "RuleRegistry",
    "FindingStore",
    "FindingFormatter",
]
```
  </action>
  <verify>
Run: `python -c "from unifi_scanner.analysis import FindingFormatter; f = FindingFormatter('America/New_York'); print(f'Timezone: {f.display_timezone}')"`
Should print: `Timezone: America/New_York`
  </verify>
  <done>
FindingFormatter converts findings to display-ready dicts with timezone-aware timestamps, occurrence summaries, grouped output by severity, and plain text report generation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive template and formatter tests</name>
  <files>tests/test_templates.py</files>
  <action>
Create `tests/test_templates.py`:

```python
"""Tests for explanation/remediation templates and FindingFormatter."""

import pytest
from datetime import datetime, timedelta, timezone

from unifi_scanner.analysis.templates import (
    EXPLANATION_TEMPLATES,
    REMEDIATION_TEMPLATES,
    render_explanation,
    render_remediation,
)
from unifi_scanner.analysis.formatter import FindingFormatter
from unifi_scanner.models.finding import Finding
from unifi_scanner.models.enums import Category, Severity


class TestExplanationTemplates:
    """Test explanation templates."""

    def test_all_templates_have_title_and_description(self):
        """Test that all explanation templates have required fields."""
        for name, template in EXPLANATION_TEMPLATES.items():
            assert "title" in template, f"Template {name} missing title"
            assert "description" in template, f"Template {name} missing description"

    def test_titles_include_category_prefix(self):
        """Test that titles include category prefix per user decision."""
        category_prefixes = ["[Security]", "[Connectivity]", "[Performance]", "[System]", "[Uncategorized]"]
        for name, template in EXPLANATION_TEMPLATES.items():
            has_prefix = any(prefix in template["title"] for prefix in category_prefixes)
            assert has_prefix, f"Template {name} title should have category prefix"

    def test_descriptions_include_event_type_placeholder(self):
        """Test that descriptions include event type for searchability."""
        for name, template in EXPLANATION_TEMPLATES.items():
            assert "{event_type}" in template["description"], (
                f"Template {name} should include {{event_type}} for Googling"
            )

    def test_render_explanation_basic(self):
        """Test basic explanation rendering."""
        context = {
            "ip": "192.168.1.100",
            "event_type": "EVT_AD_LOGIN_FAILED",
            "device_name": "UDM-Pro",
        }

        result = render_explanation("admin_login_failed", context)

        assert "192.168.1.100" in result["title"]
        assert "EVT_AD_LOGIN_FAILED" in result["description"]

    def test_render_explanation_missing_key(self):
        """Test that missing keys render as 'Unknown'."""
        context = {}  # No keys provided

        result = render_explanation("admin_login_failed", context)

        assert "Unknown" in result["title"]

    def test_render_explanation_fallback(self):
        """Test fallback to 'unknown' template."""
        context = {"event_type": "NEW_EVENT", "message": "Something new"}

        result = render_explanation("nonexistent_template", context, fallback=True)

        assert "Uncategorized" in result["title"]
        assert "NEW_EVENT" in result["description"]


class TestRemediationTemplates:
    """Test remediation templates."""

    def test_severe_rules_have_numbered_steps(self):
        """Test that SEVERE remediation has step-by-step instructions."""
        severe_rules = [
            "admin_login_failed",
            "rogue_ap_detected",
            "ips_alert",
            "ap_lost_contact",
            "switch_lost_contact",
            "gateway_wan_down",
            "ap_isolated",
        ]

        for rule in severe_rules:
            template = REMEDIATION_TEMPLATES.get(rule)
            if template:
                assert "1." in template, f"SEVERE rule {rule} should have numbered steps"
                assert "2." in template, f"SEVERE rule {rule} should have multiple steps"

    def test_render_remediation_severe(self):
        """Test rendering remediation for SEVERE severity."""
        context = {"ip": "10.0.0.50"}

        result = render_remediation("admin_login_failed", Severity.SEVERE, context)

        assert result is not None
        assert "10.0.0.50" in result
        assert "1." in result  # Has step numbers

    def test_render_remediation_medium(self):
        """Test rendering remediation for MEDIUM severity."""
        context = {"device_name": "Office AP"}

        result = render_remediation("high_cpu", Severity.MEDIUM, context)

        assert result is not None
        # MEDIUM doesn't require numbered steps per user decision

    def test_render_remediation_low_returns_none(self):
        """Test that LOW severity returns no remediation."""
        context = {"ip": "192.168.1.1"}

        result = render_remediation("admin_login_success", Severity.LOW, context)

        assert result is None


class TestFindingFormatter:
    """Test FindingFormatter."""

    @pytest.fixture
    def sample_finding(self):
        """Create a sample finding for testing."""
        return Finding(
            severity=Severity.SEVERE,
            category=Category.SECURITY,
            title="[Security] Failed login from 192.168.1.50",
            description="Someone tried to log in...",
            remediation="1. Check the IP\n2. Block if unknown",
            first_seen=datetime(2024, 1, 15, 14, 0, 0, tzinfo=timezone.utc),
            last_seen=datetime(2024, 1, 15, 16, 30, 0, tzinfo=timezone.utc),
            device_name="UDM-Pro",
            device_mac="aa:bb:cc:dd:ee:ff",
            occurrence_count=3,
        )

    def test_format_timestamp_utc(self):
        """Test timestamp formatting in UTC."""
        formatter = FindingFormatter(display_timezone="UTC")
        dt = datetime(2024, 1, 15, 14, 30, 0, tzinfo=timezone.utc)

        result = formatter.format_timestamp(dt)

        assert "2024-01-15" in result
        assert "02:30 PM" in result
        assert "UTC" in result

    def test_format_timestamp_custom_timezone(self):
        """Test timestamp formatting with custom timezone."""
        formatter = FindingFormatter(display_timezone="America/New_York")
        dt = datetime(2024, 1, 15, 14, 30, 0, tzinfo=timezone.utc)

        result = formatter.format_timestamp(dt)

        # 2:30 PM UTC = 9:30 AM EST
        assert "09:30 AM" in result

    def test_format_timestamp_invalid_timezone_fallback(self):
        """Test that invalid timezone falls back to UTC."""
        formatter = FindingFormatter(display_timezone="Invalid/Zone")

        assert formatter.display_timezone == "UTC"

    def test_format_finding(self, sample_finding):
        """Test formatting a single finding."""
        formatter = FindingFormatter()

        result = formatter.format_finding(sample_finding)

        assert result["severity"] == "severe"
        assert result["category"] == "security"
        assert result["title"] == sample_finding.title
        assert result["description"] == sample_finding.description
        assert result["has_remediation"] is True
        assert result["occurrence_count"] == 3
        assert result["is_actionable"] is True

    def test_format_occurrence_summary_single(self):
        """Test occurrence summary for single event."""
        formatter = FindingFormatter(display_timezone="UTC")
        finding = Finding(
            severity=Severity.LOW,
            category=Category.SYSTEM,
            title="Test",
            description="Test",
            first_seen=datetime(2024, 1, 15, 14, 0, 0, tzinfo=timezone.utc),
            last_seen=datetime(2024, 1, 15, 14, 0, 0, tzinfo=timezone.utc),
            occurrence_count=1,
        )

        result = formatter.format_occurrence_summary(finding)

        assert "Occurred at" in result
        assert "02:00 PM" in result

    def test_format_occurrence_summary_multiple(self, sample_finding):
        """Test occurrence summary for multiple events."""
        formatter = FindingFormatter(display_timezone="UTC")

        result = formatter.format_occurrence_summary(sample_finding)

        assert "Occurred 3 times" in result
        assert "first:" in result
        assert "last:" in result

    def test_format_occurrence_summary_recurring(self):
        """Test occurrence summary shows recurring flag."""
        formatter = FindingFormatter()
        finding = Finding(
            severity=Severity.MEDIUM,
            category=Category.CONNECTIVITY,
            title="Test",
            description="Test",
            first_seen=datetime.now(timezone.utc),
            last_seen=datetime.now(timezone.utc),
            occurrence_count=10,  # Above recurring threshold
        )

        result = formatter.format_occurrence_summary(finding)

        assert "[Recurring Issue]" in result

    def test_format_grouped_findings(self, sample_finding):
        """Test grouping findings by severity."""
        formatter = FindingFormatter()
        findings = [
            sample_finding,  # SEVERE
            Finding(
                severity=Severity.LOW,
                category=Category.SYSTEM,
                title="Low finding",
                description="...",
                first_seen=datetime.now(timezone.utc),
                last_seen=datetime.now(timezone.utc),
            ),
            Finding(
                severity=Severity.MEDIUM,
                category=Category.PERFORMANCE,
                title="Medium finding",
                description="...",
                first_seen=datetime.now(timezone.utc),
                last_seen=datetime.now(timezone.utc),
            ),
        ]

        result = formatter.format_grouped_findings(findings)

        assert len(result["severe"]) == 1
        assert len(result["medium"]) == 1
        assert len(result["low"]) == 1

    def test_format_text_report(self, sample_finding):
        """Test plain text report generation."""
        formatter = FindingFormatter()
        findings = [sample_finding]

        report = formatter.format_text_report(findings)

        assert "UNIFI NETWORK REPORT" in report
        assert "SEVERE" in report
        assert sample_finding.title in report
        assert "What to do:" in report

    def test_format_text_report_no_findings(self):
        """Test report with no findings."""
        formatter = FindingFormatter()

        report = formatter.format_text_report([])

        assert "No issues found" in report

    def test_device_name_fallback_to_mac(self):
        """Test that device_mac is used when device_name is None."""
        formatter = FindingFormatter()
        finding = Finding(
            severity=Severity.LOW,
            category=Category.SYSTEM,
            title="Test",
            description="Test",
            first_seen=datetime.now(timezone.utc),
            last_seen=datetime.now(timezone.utc),
            device_mac="aa:bb:cc:dd:ee:ff",
            device_name=None,
        )

        result = formatter.format_finding(finding)

        assert result["device_name"] == "aa:bb:cc:dd:ee:ff"


class TestUserStyleDecisions:
    """Test that user style decisions are implemented correctly."""

    def test_absolute_timestamps_not_relative(self):
        """Test that timestamps are absolute, not relative."""
        formatter = FindingFormatter()
        finding = Finding(
            severity=Severity.LOW,
            category=Category.SYSTEM,
            title="Test",
            description="Test",
            first_seen=datetime.now(timezone.utc) - timedelta(hours=2),
            last_seen=datetime.now(timezone.utc),
        )

        result = formatter.format_finding(finding)

        # Should not contain relative time words
        assert "ago" not in result["first_seen"].lower()
        assert "hours" not in result["first_seen"].lower()
        # Should contain actual date/time
        assert ":" in result["first_seen"]  # Time separator

    def test_category_visible_in_title(self):
        """Test that category prefix is in titles."""
        # This is enforced by templates
        for name, template in EXPLANATION_TEMPLATES.items():
            assert "[" in template["title"] and "]" in template["title"], (
                f"Template {name} should have category prefix in brackets"
            )

    def test_event_type_in_parentheses(self):
        """Test that event type appears in parentheses for Googling."""
        context = {"event_type": "EVT_TEST_EVENT"}

        result = render_explanation("admin_login_failed", context)

        # Event type should be in the description with parentheses
        assert "(EVT" in result["description"]
```
  </action>
  <verify>
Run: `pytest tests/test_templates.py -v`
All tests should pass.
  </verify>
  <done>
Comprehensive tests verify template structure, user style decisions (absolute timestamps, category prefixes, event type for Googling), formatter functionality, and text report generation.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from unifi_scanner.analysis.templates import EXPLANATION_TEMPLATES, REMEDIATION_TEMPLATES; print('Templates loaded')"`
2. `python -c "from unifi_scanner.analysis import FindingFormatter; print('Formatter imported')"`
3. `pytest tests/test_templates.py -v` - all tests pass
4. Integration test:
   ```python
   from datetime import datetime, timezone
   from unifi_scanner.analysis import FindingFormatter
   from unifi_scanner.models.finding import Finding
   from unifi_scanner.models.enums import Category, Severity

   finding = Finding(
       severity=Severity.SEVERE,
       category=Category.SECURITY,
       title="[Security] Failed login from 10.0.0.1",
       description="Someone tried to log in (EVT_AD_LOGIN_FAILED)...",
       remediation="1. Check IP\n2. Block if needed",
       first_seen=datetime.now(timezone.utc),
       last_seen=datetime.now(timezone.utc),
       occurrence_count=1,
   )

   formatter = FindingFormatter(display_timezone="America/Los_Angeles")
   formatted = formatter.format_finding(finding)
   print(f"Title: {formatted['title']}")
   print(f"Time: {formatted['first_seen']}")
   ```
</verification>

<success_criteria>
- EXPLANATION_TEMPLATES has entries for all rule types with title and description
- All titles include category prefix [Security], [Connectivity], [Performance], [System]
- All descriptions include {event_type} placeholder
- REMEDIATION_TEMPLATES has entries for SEVERE and MEDIUM rules
- SEVERE remediation has numbered steps (1., 2., 3., etc.)
- MEDIUM remediation has high-level guidance without strict numbering
- render_remediation() returns None for LOW severity
- FindingFormatter accepts configurable display timezone
- format_timestamp() shows absolute time with timezone abbreviation
- format_occurrence_summary() shows "Occurred N times (first: X, last: Y)"
- Recurring findings show [Recurring Issue] prefix
- format_grouped_findings() sorts SEVERE first, then MEDIUM, then LOW
- format_text_report() generates human-readable plain text output
- Device name falls back to MAC address when None
- Tests verify all user style decisions from CONTEXT.md
</success_criteria>

<output>
After completion, create `.planning/phases/03-analysis-engine/03-04-SUMMARY.md`
</output>
