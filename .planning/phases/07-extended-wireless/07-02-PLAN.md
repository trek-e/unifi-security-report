---
phase: 07-extended-wireless
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/unifi_scanner/analysis/engine.py
  - src/unifi_scanner/analysis/rules/wireless.py
  - tests/analysis/test_engine.py
  - tests/analysis/rules/test_wireless.py
autonomous: true

must_haves:
  truths:
    - "Template context includes radio_from_display and radio_to_display with human-readable bands"
    - "Template context includes rssi_quality for RSSI-to-quality translation"
    - "Analysis engine detects flapping when client roams 5+ times in 60 minutes"
    - "Flapping creates a MEDIUM severity finding with roam count and AP names"
  artifacts:
    - path: "src/unifi_scanner/analysis/engine.py"
      provides: "Extended template context with wireless fields and flapping detection"
      contains: "detect_flapping"
    - path: "src/unifi_scanner/analysis/rules/wireless.py"
      provides: "RSSI_THRESHOLDS and radio band helpers"
      contains: "rssi_to_quality"
    - path: "tests/analysis/test_engine.py"
      provides: "Flapping detection tests"
      contains: "test_flapping"
  key_links:
    - from: "src/unifi_scanner/analysis/engine.py"
      to: "src/unifi_scanner/analysis/rules/wireless.py"
      via: "imports rssi_to_quality, format_radio_band"
      pattern: "from.*wireless import"
    - from: "src/unifi_scanner/analysis/engine.py"
      to: "roaming event processing"
      via: "aggregation in analyze()"
      pattern: "detect_flapping"
---

<objective>
Add RSSI-to-quality translation (WIFI-05) and flapping detection (WIFI-06) to complete extended wireless analysis.

Purpose: Users see human-readable signal quality (Excellent/Good/Fair/Poor) and receive warnings when clients exhibit unstable roaming behavior indicating network coverage issues.

Output: Extended template context with wireless fields, rssi_to_quality helper, and flapping detection in analysis engine.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-extended-wireless/07-RESEARCH.md
@.planning/phases/07-extended-wireless/07-01-SUMMARY.md

# Files to extend
@src/unifi_scanner/analysis/engine.py
@src/unifi_scanner/analysis/rules/wireless.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RSSI and radio band helpers to wireless.py</name>
  <files>
    src/unifi_scanner/analysis/rules/wireless.py
  </files>
  <action>
Add helper functions and constants to wireless.py (above WIRELESS_RULES):

**RSSI Thresholds (from research):**
```python
RSSI_THRESHOLDS = {
    "Excellent": -50,   # >= -50 dBm
    "Good": -60,        # -50 to -60 dBm
    "Fair": -70,        # -60 to -70 dBm
    "Poor": -80,        # -70 to -80 dBm
    # < -80 dBm = Very Poor
}

def rssi_to_quality(rssi: Optional[int]) -> str:
    """Convert RSSI (dBm) to human-readable quality label.

    Args:
        rssi: Signal strength in dBm (negative number) or None

    Returns:
        Quality label: Excellent, Good, Fair, Poor, or Very Poor
    """
    if rssi is None:
        return "Unknown"
    if rssi >= -50:
        return "Excellent"
    elif rssi >= -60:
        return "Good"
    elif rssi >= -70:
        return "Fair"
    elif rssi >= -80:
        return "Poor"
    else:
        return "Very Poor"
```

**Radio Band Mapping (from research):**
```python
RADIO_BANDS = {
    "ng": "2.4GHz",
    "na": "5GHz",
    "6e": "6GHz",
}

def format_radio_band(radio_code: Optional[str]) -> str:
    """Convert UniFi radio code to human-readable band.

    Args:
        radio_code: UniFi code (ng, na, 6e) or None

    Returns:
        Human-readable band name or original code if unknown
    """
    if radio_code is None:
        return "Unknown"
    return RADIO_BANDS.get(radio_code, radio_code)
```

Export these in the module (add to imports/exports as needed).
  </action>
  <verify>
    - `python -c "from unifi_scanner.analysis.rules.wireless import rssi_to_quality; print(rssi_to_quality(-55))"` outputs "Good"
    - `python -c "from unifi_scanner.analysis.rules.wireless import format_radio_band; print(format_radio_band('na'))"` outputs "5GHz"
  </verify>
  <done>
    - rssi_to_quality function handles all threshold ranges
    - format_radio_band converts ng/na/6e to human-readable bands
    - Functions handle None gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend template context and add flapping detection</name>
  <files>
    src/unifi_scanner/analysis/engine.py
  </files>
  <action>
1. **Import helpers from wireless.py:**
   ```python
   from unifi_scanner.analysis.rules.wireless import rssi_to_quality, format_radio_band
   ```

2. **Extend _build_template_context() method:**
   Add wireless-specific fields after existing context extraction:
   ```python
   # Wireless-specific fields from raw_data
   raw = entry.raw_data or {}

   # Radio band translation (ng -> 2.4GHz, na -> 5GHz)
   context["radio_from"] = raw.get("radio_from")
   context["radio_to"] = raw.get("radio_to")
   context["radio_from_display"] = format_radio_band(raw.get("radio_from"))
   context["radio_to_display"] = format_radio_band(raw.get("radio_to"))

   # Channel information
   context["channel_from"] = raw.get("channel_from", "Unknown")
   context["channel_to"] = raw.get("channel_to", raw.get("channel", "Unknown"))

   # AP roaming fields
   context["ap_from"] = raw.get("ap_from", "Unknown")
   context["ap_to"] = raw.get("ap_to", "Unknown")
   # Extract AP names from message if present (format: "from ap[Name] to ap[Name]")
   context["ap_from_name"] = raw.get("ap_from_name", raw.get("ap_from", "Unknown"))
   context["ap_to_name"] = raw.get("ap_to_name", raw.get("ap_to", "Unknown"))

   # RSSI to quality translation
   rssi = raw.get("rssi") or raw.get("signal")
   if isinstance(rssi, (int, float)):
       context["rssi"] = int(rssi)
       context["rssi_quality"] = rssi_to_quality(int(rssi))
   else:
       context["rssi"] = None
       context["rssi_quality"] = "Unknown"

   # Client identifier for roaming
   context["client_mac"] = raw.get("user", raw.get("client", "Unknown"))
   context["ssid"] = raw.get("ssid", "Unknown")
   ```

3. **Add flapping detection to analyze() method:**
   After the main loop that creates findings, add aggregation logic:
   ```python
   def analyze(self, entries: List[LogEntry]) -> List[Finding]:
       """Analyze multiple log entries.
       ...existing docstring...
       """
       findings = []
       roam_events_by_client: Dict[str, List[LogEntry]] = {}

       for entry in entries:
           finding = self.analyze_entry(entry)
           if finding:
               findings.append(finding)

           # Track roaming events for flapping detection
           if entry.event_type in ["EVT_WU_Roam", "EVT_WG_Roam"]:
               client_mac = (entry.raw_data or {}).get("user", "unknown")
               if client_mac not in roam_events_by_client:
                   roam_events_by_client[client_mac] = []
               roam_events_by_client[client_mac].append(entry)

       # Detect flapping (WIFI-06): 5+ roams within analysis window
       flapping_findings = self._detect_flapping(roam_events_by_client, threshold=5)
       findings.extend(flapping_findings)

       logger.info(
           "analysis_complete",
           entries_processed=len(entries),
           findings_created=len(findings),
           flapping_clients=len(flapping_findings),
           unknown_types=len(self._unknown_event_types),
       )
       return findings
   ```

4. **Add _detect_flapping() method:**
   ```python
   def _detect_flapping(
       self,
       roam_events_by_client: Dict[str, List[LogEntry]],
       threshold: int = 5,
   ) -> List[Finding]:
       """Detect clients with excessive roaming (flapping).

       WIFI-06: Creates MEDIUM severity finding when client roams
       more than threshold times within the analysis window.

       Args:
           roam_events_by_client: Dict mapping client MAC to roam events
           threshold: Minimum roams to trigger flapping warning (default: 5)

       Returns:
           List of flapping Finding objects
       """
       findings = []

       for client_mac, events in roam_events_by_client.items():
           if len(events) < threshold:
               continue

           # Get unique APs involved
           ap_names = set()
           for event in events:
               raw = event.raw_data or {}
               ap_from = raw.get("ap_from_name", raw.get("ap_from", ""))
               ap_to = raw.get("ap_to_name", raw.get("ap_to", ""))
               if ap_from:
                   ap_names.add(ap_from)
               if ap_to:
                   ap_names.add(ap_to)

           ap_list = ", ".join(sorted(ap_names)) if ap_names else "multiple APs"

           finding = Finding(
               severity=Severity.MEDIUM,
               category=Category.WIRELESS,
               title=f"[Wireless] Client flapping detected ({len(events)} roams)",
               description=(
                   f"Client {client_mac} roamed {len(events)} times during this analysis period, "
                   f"which suggests unstable connectivity. The client moved between: {ap_list}. "
                   "Frequent roaming (flapping) typically indicates coverage gaps, interference, "
                   "or misconfigured roaming thresholds."
               ),
               remediation=(
                   "1. Check for coverage gaps between the APs - client may be in a dead zone\n"
                   "2. Verify AP power levels are balanced (not too high or low)\n"
                   "3. Check for interference sources causing signal fluctuation\n"
                   "4. Consider adjusting Min-RSSI settings if using BSS Transition\n"
                   "5. If client is stationary, it may have a faulty wireless adapter"
               ),
               source_log_ids=[e.id for e in events],
               first_seen=min(e.timestamp for e in events),
               last_seen=max(e.timestamp for e in events),
               device_mac=client_mac,
               device_name=client_mac,  # Client MAC as identifier
               metadata={
                   "rule_name": "client_flapping",
                   "event_type": "aggregation",
                   "roam_count": len(events),
                   "aps_involved": list(ap_names),
               },
           )
           findings.append(finding)
           logger.info(
               "flapping_detected",
               client=client_mac,
               roam_count=len(events),
               aps=list(ap_names),
           )

       return findings
   ```

Note: Import Category and Finding at top if not already imported.
  </action>
  <verify>
    - `python -c "from unifi_scanner.analysis.engine import AnalysisEngine; print('AnalysisEngine imports OK')"` succeeds
    - `grep -q "detect_flapping" src/unifi_scanner/analysis/engine.py && echo "Flapping detection added"`
  </verify>
  <done>
    - Template context includes radio_from_display, radio_to_display, rssi_quality, ap_from_name, ap_to_name
    - Flapping detection runs after main analysis loop
    - Flapping threshold is 5 roams per analysis window
    - Flapping finding includes roam count, AP list, and remediation steps
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for RSSI, radio bands, and flapping detection</name>
  <files>
    tests/analysis/rules/test_wireless.py
    tests/analysis/test_engine.py
  </files>
  <action>
1. **Add tests to test_wireless.py for helpers:**
   ```python
   # RSSI translation tests (WIFI-05)
   def test_rssi_to_quality_excellent():
       assert rssi_to_quality(-45) == "Excellent"
       assert rssi_to_quality(-50) == "Excellent"

   def test_rssi_to_quality_good():
       assert rssi_to_quality(-55) == "Good"
       assert rssi_to_quality(-60) == "Good"

   def test_rssi_to_quality_fair():
       assert rssi_to_quality(-65) == "Fair"
       assert rssi_to_quality(-70) == "Fair"

   def test_rssi_to_quality_poor():
       assert rssi_to_quality(-75) == "Poor"
       assert rssi_to_quality(-80) == "Poor"

   def test_rssi_to_quality_very_poor():
       assert rssi_to_quality(-85) == "Very Poor"
       assert rssi_to_quality(-90) == "Very Poor"

   def test_rssi_to_quality_none():
       assert rssi_to_quality(None) == "Unknown"

   # Radio band translation tests
   def test_format_radio_band_24ghz():
       assert format_radio_band("ng") == "2.4GHz"

   def test_format_radio_band_5ghz():
       assert format_radio_band("na") == "5GHz"

   def test_format_radio_band_6ghz():
       assert format_radio_band("6e") == "6GHz"

   def test_format_radio_band_unknown():
       assert format_radio_band("xyz") == "xyz"  # Returns original if unknown

   def test_format_radio_band_none():
       assert format_radio_band(None) == "Unknown"
   ```

2. **Add flapping detection tests to test_engine.py:**
   ```python
   def test_flapping_detection_triggers_above_threshold():
       """WIFI-06: 5+ roams triggers flapping finding."""
       from unifi_scanner.analysis.rules import get_default_registry

       engine = AnalysisEngine(registry=get_default_registry())

       # Create 6 roaming events for same client
       entries = []
       for i in range(6):
           entry = LogEntry(
               id=f"roam-{i}",
               timestamp=datetime.now(UTC),
               event_type="EVT_WU_Roam",
               message=f"Client roamed from AP{i} to AP{i+1}",
               raw_data={
                   "user": "aa:bb:cc:dd:ee:ff",
                   "ap_from": f"AP{i}",
                   "ap_to": f"AP{i+1}",
               },
           )
           entries.append(entry)

       findings = engine.analyze(entries)

       # Should have 6 individual roam findings + 1 flapping finding
       flapping_findings = [f for f in findings if "flapping" in f.title.lower()]
       assert len(flapping_findings) == 1
       assert flapping_findings[0].severity == Severity.MEDIUM
       assert flapping_findings[0].category == Category.WIRELESS
       assert "6 roams" in flapping_findings[0].title

   def test_flapping_detection_below_threshold():
       """No flapping finding when roams < 5."""
       from unifi_scanner.analysis.rules import get_default_registry

       engine = AnalysisEngine(registry=get_default_registry())

       # Create only 3 roaming events
       entries = []
       for i in range(3):
           entry = LogEntry(
               id=f"roam-{i}",
               timestamp=datetime.now(UTC),
               event_type="EVT_WU_Roam",
               message=f"Client roamed",
               raw_data={"user": "aa:bb:cc:dd:ee:ff"},
           )
           entries.append(entry)

       findings = engine.analyze(entries)

       flapping_findings = [f for f in findings if "flapping" in f.title.lower()]
       assert len(flapping_findings) == 0

   def test_flapping_detection_separate_clients():
       """Different clients tracked separately for flapping."""
       from unifi_scanner.analysis.rules import get_default_registry

       engine = AnalysisEngine(registry=get_default_registry())

       entries = []
       # 3 roams for client A (below threshold)
       for i in range(3):
           entries.append(LogEntry(
               id=f"a-{i}",
               timestamp=datetime.now(UTC),
               event_type="EVT_WU_Roam",
               message="roam",
               raw_data={"user": "client-a"},
           ))
       # 3 roams for client B (below threshold)
       for i in range(3):
           entries.append(LogEntry(
               id=f"b-{i}",
               timestamp=datetime.now(UTC),
               event_type="EVT_WU_Roam",
               message="roam",
               raw_data={"user": "client-b"},
           ))

       findings = engine.analyze(entries)

       # Neither client should trigger flapping
       flapping_findings = [f for f in findings if "flapping" in f.title.lower()]
       assert len(flapping_findings) == 0
   ```

Add necessary imports at top of test files (datetime, UTC, LogEntry, Severity, Category).
  </action>
  <verify>
    - `cd /Users/trekkie/projects/unifi_scanner && python -m pytest tests/analysis/rules/test_wireless.py -v -k "rssi or radio"` passes
    - `cd /Users/trekkie/projects/unifi_scanner && python -m pytest tests/analysis/test_engine.py -v -k "flapping"` passes
  </verify>
  <done>
    - RSSI threshold tests cover all quality levels and edge cases
    - Radio band tests verify ng/na/6e translation
    - Flapping tests verify threshold behavior (5+ triggers, <5 does not)
    - Flapping tests verify separate client tracking
    - All tests pass
  </done>
</task>

</tasks>

<verification>
1. Helper function verification:
   ```bash
   python -c "
   from unifi_scanner.analysis.rules.wireless import rssi_to_quality, format_radio_band
   print('RSSI -45:', rssi_to_quality(-45))
   print('RSSI -65:', rssi_to_quality(-65))
   print('RSSI -85:', rssi_to_quality(-85))
   print('Radio na:', format_radio_band('na'))
   print('Radio ng:', format_radio_band('ng'))
   "
   ```

2. Template context verification:
   ```bash
   python -c "
   from unifi_scanner.analysis.engine import AnalysisEngine
   from unifi_scanner.models.log_entry import LogEntry
   from datetime import datetime, UTC

   engine = AnalysisEngine()
   entry = LogEntry(
       id='test',
       timestamp=datetime.now(UTC),
       event_type='EVT_WU_Roam',
       message='roam',
       raw_data={'radio_from': 'ng', 'radio_to': 'na', 'rssi': -55},
   )
   ctx = engine._build_template_context(entry)
   print('radio_from_display:', ctx.get('radio_from_display'))
   print('radio_to_display:', ctx.get('radio_to_display'))
   print('rssi_quality:', ctx.get('rssi_quality'))
   "
   ```

3. Full test suite:
   ```bash
   cd /Users/trekkie/projects/unifi_scanner && python -m pytest tests/analysis/ -v
   ```
</verification>

<success_criteria>
- rssi_to_quality returns Excellent/Good/Fair/Poor/Very Poor based on thresholds
- format_radio_band converts ng->2.4GHz, na->5GHz, 6e->6GHz
- Template context includes wireless-specific fields
- Flapping detection triggers at 5+ roams per client
- Flapping finding includes roam count, AP list, and remediation
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-extended-wireless/07-02-SUMMARY.md`
</output>
