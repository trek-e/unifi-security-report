---
phase: 08-enhanced-security
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/unifi_scanner/analysis/ips/analyzer.py
  - src/unifi_scanner/reports/templates/threat_section.html
  - src/unifi_scanner/reports/templates/threat_section.txt
  - tests/test_ips_analyzer.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Report provides category-specific remediation guidance for security findings"
    - "ThreatSummary contains remediation text populated from get_remediation()"
    - "HTML and text templates display remediation for detected threats"
  artifacts:
    - path: "src/unifi_scanner/analysis/ips/analyzer.py"
      provides: "ThreatSummary with remediation field"
      contains: "remediation: Optional[str]"
    - path: "src/unifi_scanner/reports/templates/threat_section.html"
      provides: "Remediation display in threat cards"
      contains: "threat.remediation"
    - path: "src/unifi_scanner/reports/templates/threat_section.txt"
      provides: "Remediation display in text format"
      contains: "threat.remediation"
  key_links:
    - from: "src/unifi_scanner/analysis/ips/analyzer.py"
      to: "remediation.get_remediation"
      via: "_create_threat_summaries calls get_remediation"
      pattern: "get_remediation\\("
    - from: "threat_section.html"
      to: "ThreatSummary.remediation"
      via: "Jinja template displays remediation"
      pattern: "threat\\.remediation"
---

<objective>
Wire remediation guidance into IPS threat analysis and report templates

Purpose: Close the gap where remediation templates exist (571 lines, 24 categories) but are never integrated into the analysis flow or reports. Users currently see WHAT happened but not WHAT TO DO. This completes Success Criteria #4 and SECR-05.

Output:
- ThreatSummary with remediation field populated by get_remediation()
- HTML/text templates displaying actionable remediation for detected threats
- Tests verifying remediation flows through the full pipeline
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-enhanced-security/08-VERIFICATION.md

# Key source files
@src/unifi_scanner/analysis/ips/analyzer.py
@src/unifi_scanner/analysis/ips/remediation.py
@src/unifi_scanner/reports/templates/threat_section.html
@src/unifi_scanner/reports/templates/threat_section.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add remediation field to ThreatSummary and wire get_remediation()</name>
  <files>src/unifi_scanner/analysis/ips/analyzer.py</files>
  <action>
1. Add import at top of file:
   ```python
   from unifi_scanner.analysis.ips.remediation import get_remediation
   ```

2. Add `remediation` field to ThreatSummary dataclass (after source_ips, line ~75):
   ```python
   remediation: Optional[str] = None
   ```

3. In `_create_threat_summaries()`, after determining severity (~line 222), call get_remediation:
   ```python
   # Get remediation guidance for this threat
   remediation_context = {
       "src_ip": list(data["source_ips"])[0] if data["source_ips"] else "[unknown]",
       "dest_ip": "[target]",
       "signature": signature,
   }
   remediation_text = get_remediation(
       first_event.category_raw,
       max_severity,
       remediation_context,
   )
   ```

4. Add remediation to ThreatSummary constructor (~line 224):
   ```python
   summary = ThreatSummary(
       category_friendly=friendly_name,
       description=_get_category_description(first_event.category_raw),
       count=len(event_list),
       severity=max_severity,
       sample_signature=signature,
       source_ips=list(data["source_ips"]),
       remediation=remediation_text,
   )
   ```

Note: Remediation uses the first source IP as context. This is acceptable because threats are grouped by signature, so the remediation applies to all events with that signature.
  </action>
  <verify>
Run: `python -c "from unifi_scanner.analysis.ips.analyzer import ThreatSummary; print('remediation' in ThreatSummary.__dataclass_fields__)"`
Expected: True

Run: `python -c "from unifi_scanner.analysis.ips.analyzer import IPSAnalyzer; from unifi_scanner.analysis.ips.models import IPSEvent; e = IPSEvent.from_api_event({'time': 1706140800000, 'msg': 'ET SCAN test', 'signature': 'ET SCAN test', 'src_ip': '8.8.8.8', 'dst_ip': '192.168.1.1', 'inner_alert_action': 'drop', 'inner_alert_severity': 2}); r = IPSAnalyzer().process_events([e]); print(r.blocked_threats[0].remediation is not None if r.blocked_threats else False)"`
Expected: True
  </verify>
  <done>ThreatSummary has remediation field and _create_threat_summaries() populates it via get_remediation()</done>
</task>

<task type="auto">
  <name>Task 2: Update templates to display remediation guidance</name>
  <files>
    src/unifi_scanner/reports/templates/threat_section.html
    src/unifi_scanner/reports/templates/threat_section.txt
  </files>
  <action>
**HTML template (threat_section.html):**

After the Sources line (around line 52), add remediation display:
```html
{% if threat.remediation %}
<div style="margin-top: 10px; padding: 10px 12px; background-color: #f8f9fa; border-radius: 4px; border-left: 3px solid #17a2b8;">
    <p style="margin: 0 0 4px 0; font-size: 12px; font-weight: 600; color: #17a2b8; text-transform: uppercase;">Recommended Actions</p>
    <p style="margin: 0; color: #495057; font-size: 13px; white-space: pre-line;">{{ threat.remediation }}</p>
</div>
{% endif %}
```

This should be inside the threat card div (before the closing </div> around line 54), only for detected threats (not blocked - blocked threats don't need remediation since they were stopped).

**Text template (threat_section.txt):**

After the Sources line (around line 36), add:
```
{% if threat.remediation %}
Recommended Actions:
{{ threat.remediation }}
{% endif %}
```

Note: Only show remediation for detected threats (not blocked threats). Blocked threats were already stopped by IPS, so users don't need action steps. The detected threats section is the one where users need guidance.
  </action>
  <verify>
Run quick template render test:
```python
from jinja2 import Environment, FileSystemLoader
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Optional
from unifi_scanner.models.enums import Severity

@dataclass
class MockThreat:
    category_friendly: str = "Reconnaissance"
    description: str = "Test"
    count: int = 5
    severity: Severity = Severity.MEDIUM
    sample_signature: str = "ET SCAN test"
    source_ips: List[str] = field(default_factory=lambda: ["8.8.8.8"])
    remediation: str = "1. Check the source\n2. Block if malicious"

@dataclass
class MockAnalysis:
    detected_threats: List[MockThreat] = field(default_factory=lambda: [MockThreat()])
    blocked_threats: List = field(default_factory=list)
    external_source_ips: List = field(default_factory=list)
    internal_source_ips: List = field(default_factory=list)
    detection_mode_note: Optional[str] = None

env = Environment(loader=FileSystemLoader("src/unifi_scanner/reports/templates"))
html = env.get_template("threat_section.html").render(ips_analysis=MockAnalysis())
txt = env.get_template("threat_section.txt").render(ips_analysis=MockAnalysis())
print("HTML has remediation:", "Recommended Actions" in html)
print("TXT has remediation:", "Recommended Actions" in txt)
```
Expected: Both True
  </verify>
  <done>Templates display remediation guidance for detected threats with clear "Recommended Actions" heading</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for remediation in threat summaries</name>
  <files>tests/test_ips_analyzer.py</files>
  <action>
Add test cases to verify remediation flows through the analyzer:

```python
class TestRemediationIntegration:
    """Test remediation integration in IPSAnalyzer."""

    def test_threat_summary_includes_remediation(self):
        """ThreatSummary should have remediation populated from get_remediation()."""
        events = [
            IPSEvent.from_api_event({
                "time": 1706140800000,
                "msg": "ET SCAN Potential SSH Scan",
                "signature": "ET SCAN Potential SSH Scan",
                "src_ip": "203.0.113.50",
                "dst_ip": "192.168.1.100",
                "inner_alert_action": "alert",  # detected, not blocked
                "inner_alert_severity": 2,
            })
        ]

        analyzer = IPSAnalyzer()
        result = analyzer.process_events(events)

        # Should have one detected threat
        assert len(result.detected_threats) == 1
        threat = result.detected_threats[0]

        # Remediation should be populated
        assert threat.remediation is not None
        assert len(threat.remediation) > 0
        # SCAN category remediation mentions source IP investigation
        assert "source" in threat.remediation.lower() or "scan" in threat.remediation.lower()

    def test_blocked_threat_also_has_remediation(self):
        """Even blocked threats should have remediation (for awareness)."""
        events = [
            IPSEvent.from_api_event({
                "time": 1706140800000,
                "msg": "ET MALWARE Known Trojan",
                "signature": "ET MALWARE Known Trojan",
                "src_ip": "8.8.8.8",
                "dst_ip": "192.168.1.100",
                "inner_alert_action": "drop",  # blocked
                "inner_alert_severity": 1,
            })
        ]

        analyzer = IPSAnalyzer()
        result = analyzer.process_events(events)

        assert len(result.blocked_threats) == 1
        threat = result.blocked_threats[0]

        # Remediation should still be populated
        assert threat.remediation is not None
        # MALWARE severe remediation mentions isolation
        assert "isolate" in threat.remediation.lower() or "scan" in threat.remediation.lower()

    def test_remediation_uses_severity_adjusted_template(self):
        """Remediation detail should vary by severity."""
        # Create severe event
        severe_event = IPSEvent.from_api_event({
            "time": 1706140800000,
            "msg": "ET MALWARE Severe Threat",
            "signature": "ET MALWARE Severe Threat",
            "src_ip": "8.8.8.8",
            "dst_ip": "192.168.1.100",
            "inner_alert_action": "alert",
            "inner_alert_severity": 1,  # severity 1 = severe
        })

        # Create low severity event
        low_event = IPSEvent.from_api_event({
            "time": 1706140800000,
            "msg": "ET INFO Low Priority",
            "signature": "ET INFO Low Priority",
            "src_ip": "8.8.8.8",
            "dst_ip": "192.168.1.100",
            "inner_alert_action": "alert",
            "inner_alert_severity": 3,  # severity 3 = low
        })

        analyzer = IPSAnalyzer()
        severe_result = analyzer.process_events([severe_event])
        low_result = analyzer.process_events([low_event])

        severe_remediation = severe_result.detected_threats[0].remediation
        low_remediation = low_result.detected_threats[0].remediation

        # Severe should have numbered steps (step-by-step)
        # Low should be shorter (explanation only)
        assert severe_remediation is not None
        # Severe MALWARE remediation has numbered steps
        if "1." in severe_remediation:
            assert len(severe_remediation) > len(low_remediation or "")
```

Place this test class at the end of test_ips_analyzer.py.
  </action>
  <verify>
Run: `python -m pytest tests/test_ips_analyzer.py::TestRemediationIntegration -v`
Expected: All 3 tests pass
  </verify>
  <done>Tests confirm remediation is populated in ThreatSummary and varies by severity</done>
</task>

</tasks>

<verification>
1. Run full IPS test suite: `python -m pytest tests/test_ips*.py -v`
2. Run integration tests: `python -m pytest tests/test_ips_integration.py -v`
3. Verify remediation appears in template output:
   ```python
   # Quick manual verification
   from unifi_scanner.analysis.ips.analyzer import IPSAnalyzer
   from unifi_scanner.analysis.ips.models import IPSEvent

   event = IPSEvent.from_api_event({
       "time": 1706140800000,
       "msg": "ET SCAN Potential SSH Scan",
       "signature": "ET SCAN Potential SSH Scan",
       "src_ip": "8.8.8.8",
       "dst_ip": "192.168.1.1",
       "inner_alert_action": "alert",
       "inner_alert_severity": 2,
   })
   result = IPSAnalyzer().process_events([event])
   threat = result.detected_threats[0]
   print(f"Category: {threat.category_friendly}")
   print(f"Remediation: {threat.remediation}")
   ```
   Expected: Remediation text with actionable steps for SCAN category
</verification>

<success_criteria>
- ThreatSummary has `remediation: Optional[str]` field
- `_create_threat_summaries()` calls `get_remediation()` to populate remediation
- HTML template displays remediation in styled box for detected threats
- Text template displays remediation with "Recommended Actions:" header
- All existing tests pass
- 3 new tests verify remediation integration
- Gap from VERIFICATION.md is closed: "Report provides category-specific remediation guidance"
</success_criteria>

<output>
After completion, create `.planning/phases/08-enhanced-security/08-05-SUMMARY.md`
</output>
