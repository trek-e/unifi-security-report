---
phase: 10-integration-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/unifi_scanner/integrations/__init__.py
  - src/unifi_scanner/integrations/base.py
  - src/unifi_scanner/integrations/registry.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Integration Protocol defines is_configured(), validate_config(), and fetch() methods"
    - "IntegrationResult captures success/failure with optional data and error"
    - "IntegrationRegistry can register and retrieve configured integrations"
    - "pybreaker is added to project dependencies"
  artifacts:
    - path: "src/unifi_scanner/integrations/base.py"
      provides: "Integration Protocol and result models"
      exports: ["Integration", "IntegrationResult", "IntegrationSection"]
    - path: "src/unifi_scanner/integrations/registry.py"
      provides: "Integration registry for managing integrations"
      exports: ["IntegrationRegistry"]
    - path: "src/unifi_scanner/integrations/__init__.py"
      provides: "Public exports for integrations module"
    - path: "pyproject.toml"
      provides: "pybreaker dependency"
      contains: "pybreaker"
  key_links:
    - from: "src/unifi_scanner/integrations/registry.py"
      to: "src/unifi_scanner/integrations/base.py"
      via: "imports Integration Protocol"
      pattern: "from.*base import.*Integration"
---

<objective>
Create the core integration infrastructure: Protocol-based interface, result models, and registry.

Purpose: Establish the foundation that all external integrations (Cloudflare, Cybersecure) will implement. This enables Phase 11 and 12 to add integrations that plug into this framework.

Output: New `integrations` module with Protocol, models, registry, and pybreaker dependency added.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-integration-infrastructure/10-CONTEXT.md
@.planning/phases/10-integration-infrastructure/10-RESEARCH.md
@pyproject.toml
@src/unifi_scanner/analysis/device_health/models.py
@src/unifi_scanner/analysis/device_health/analyzer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Integration Protocol and result models</name>
  <files>
    src/unifi_scanner/integrations/__init__.py
    src/unifi_scanner/integrations/base.py
  </files>
  <action>
Create `src/unifi_scanner/integrations/` module with base types:

**base.py:**
1. Import `typing.Protocol` for interface definition (not ABC - per RESEARCH.md)
2. Create `IntegrationResult` dataclass:
   - `name: str` - integration identifier
   - `success: bool` - whether fetch succeeded
   - `data: Optional[Dict[str, Any]] = None` - integration-specific data
   - `error: Optional[str] = None` - error message if failed

3. Create `IntegrationSection` dataclass for report rendering:
   - `name: str` - integration identifier (e.g., "cloudflare")
   - `display_name: str` - human-readable name (e.g., "Cloudflare Security")
   - `success: bool` - whether data was fetched
   - `data: Optional[Dict[str, Any]] = None` - data for template
   - `error_message: Optional[str] = None` - e.g., "Unable to fetch data"

4. Create `IntegrationResults` dataclass for aggregated results:
   - `sections: List[IntegrationSection]` - all integration sections
   - `has_data` property: returns True if any section has data
   - `get_section(name)` method: get specific section by name

5. Create `Integration` Protocol:
   - `name` property (str) - unique identifier
   - `is_configured() -> bool` - True only when ALL required credentials present
   - `validate_config() -> Optional[str]` - None if valid, warning message if partial
   - `async def fetch() -> IntegrationResult` - fetch data from external service

**__init__.py:**
Export all public types: `Integration`, `IntegrationResult`, `IntegrationSection`, `IntegrationResults`

Follow existing dataclass patterns from `analysis/device_health/models.py`.
Use `from __future__ import annotations` for forward references.
  </action>
  <verify>
    python -c "from unifi_scanner.integrations import Integration, IntegrationResult, IntegrationSection, IntegrationResults; print('imports ok')"
  </verify>
  <done>
    Integration Protocol and result models importable from unifi_scanner.integrations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IntegrationRegistry and add pybreaker dependency</name>
  <files>
    src/unifi_scanner/integrations/registry.py
    src/unifi_scanner/integrations/__init__.py
    pyproject.toml
  </files>
  <action>
**registry.py:**
1. Create `IntegrationRegistry` class:
   - Class attribute `_integration_classes: List[Type[Integration]] = []` (hardcoded, not dynamic per CONTEXT.md)
   - `@classmethod register(cls, integration_class)` - add integration class to registry
   - `@classmethod get_configured(cls, settings) -> List[Integration]` - instantiate and return only configured integrations
   - `@classmethod get_all(cls, settings) -> List[Integration]` - instantiate all integrations (for validation warnings)

2. The registry should:
   - Instantiate each integration class with settings
   - Call `is_configured()` to filter
   - Call `validate_config()` and log warnings for partial configs
   - Return empty list if no integrations configured (silent skip per CONTEXT.md)

3. Use structlog for warning logs when partial config detected

**Update __init__.py:**
Add `IntegrationRegistry` to exports

**pyproject.toml:**
Add `"pybreaker>=1.4"` to dependencies list (between pyyaml and python-dotenv alphabetically or at end)

Note: The registry will be empty initially - Cloudflare and Cybersecure integrations register themselves in Phase 11 and 12.
  </action>
  <verify>
    python -c "from unifi_scanner.integrations import IntegrationRegistry; print('registry ok')"
    grep -q "pybreaker" pyproject.toml && echo "pybreaker dependency added"
  </verify>
  <done>
    IntegrationRegistry available, pybreaker in dependencies
  </done>
</task>

</tasks>

<verification>
```bash
# Verify imports work
python -c "
from unifi_scanner.integrations import (
    Integration,
    IntegrationResult,
    IntegrationSection,
    IntegrationResults,
    IntegrationRegistry,
)
print('All integration types importable')
"

# Verify pybreaker can be imported (after pip install)
pip install pybreaker
python -c "import pybreaker; print(f'pybreaker {pybreaker.__version__}')"

# Verify Protocol structure
python -c "
from unifi_scanner.integrations.base import Integration
import inspect
# Protocol should have expected methods
print('Protocol defined correctly')
"
```
</verification>

<success_criteria>
1. `integrations` module created with base.py, registry.py, __init__.py
2. Integration Protocol defines name, is_configured, validate_config, fetch
3. IntegrationResult, IntegrationSection, IntegrationResults dataclasses exist
4. IntegrationRegistry can register and retrieve integrations
5. pybreaker>=1.4 added to pyproject.toml dependencies
6. All types importable from unifi_scanner.integrations
</success_criteria>

<output>
After completion, create `.planning/phases/10-integration-infrastructure/10-01-SUMMARY.md`
</output>
