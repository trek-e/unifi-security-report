---
phase: 10-integration-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/unifi_scanner/integrations/runner.py
  - src/unifi_scanner/integrations/__init__.py
autonomous: true

must_haves:
  truths:
    - "IntegrationRunner executes integrations in parallel with asyncio.gather"
    - "Each integration has its own circuit breaker (not shared)"
    - "Circuit breaker opens after 3 failures and resets after 60 seconds"
    - "One integration failing does not prevent others from running"
    - "Timeout of 30 seconds per integration prevents slow integrations from blocking"
  artifacts:
    - path: "src/unifi_scanner/integrations/runner.py"
      provides: "IntegrationRunner with circuit breaker and parallel execution"
      exports: ["IntegrationRunner"]
    - path: "src/unifi_scanner/integrations/__init__.py"
      provides: "Updated exports including IntegrationRunner"
  key_links:
    - from: "src/unifi_scanner/integrations/runner.py"
      to: "pybreaker"
      via: "circuit breaker wrapper"
      pattern: "pybreaker\\.CircuitBreaker"
    - from: "src/unifi_scanner/integrations/runner.py"
      to: "asyncio.gather"
      via: "parallel execution"
      pattern: "asyncio\\.gather.*return_exceptions.*True"
---

<objective>
Create IntegrationRunner that executes integrations in parallel with circuit breakers and complete failure isolation.

Purpose: Implement INTG-02 (failure isolation) and INTG-03 (circuit breakers). This ensures one integration failing doesn't break others and external API failures are handled gracefully.

Output: IntegrationRunner class that runs all configured integrations in parallel, wraps each with a circuit breaker, and returns aggregated results.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-integration-infrastructure/10-CONTEXT.md
@.planning/phases/10-integration-infrastructure/10-RESEARCH.md
@src/unifi_scanner/integrations/base.py
@src/unifi_scanner/integrations/registry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create circuit breaker utilities</name>
  <files>
    src/unifi_scanner/integrations/runner.py
  </files>
  <action>
Create `runner.py` with circuit breaker support:

1. Import pybreaker and create `CircuitBreakerLoggingListener`:
   - Inherit from `pybreaker.CircuitBreakerListener`
   - Override `state_change(cb, old_state, new_state)`:
     - Log WARNING when state changes to "open" (circuit tripped)
     - Log INFO when state changes to "closed" (circuit recovered)
   - Use structlog for logging with integration name in context

2. Create `create_circuit_breaker(name: str) -> pybreaker.CircuitBreaker`:
   - `name`: integration name for logging
   - `fail_max=3`: open after 3 consecutive failures (per RESEARCH.md)
   - `reset_timeout=60`: try again after 60 seconds
   - Add the logging listener

3. Define module-level constants:
   - `INTEGRATION_TIMEOUT = 30` (seconds per integration)
   - `CIRCUIT_FAIL_MAX = 3`
   - `CIRCUIT_RESET_TIMEOUT = 60`

4. Create dict to cache circuit breakers by integration name:
   - `_circuit_breakers: Dict[str, pybreaker.CircuitBreaker] = {}`
   - `get_circuit_breaker(name: str) -> pybreaker.CircuitBreaker` that creates on first access

Per CONTEXT.md: In-memory state only (resets on restart). Log once when tripped, not each skip.
  </action>
  <verify>
    python -c "from unifi_scanner.integrations.runner import create_circuit_breaker; cb = create_circuit_breaker('test'); print(f'Circuit breaker created: {cb.name}')"
  </verify>
  <done>
    Circuit breaker factory function works, creates breaker with fail_max=3, reset_timeout=60
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IntegrationRunner with parallel execution</name>
  <files>
    src/unifi_scanner/integrations/runner.py
    src/unifi_scanner/integrations/__init__.py
  </files>
  <action>
Add `IntegrationRunner` class to runner.py:

1. `__init__(self, settings)`:
   - Store settings for passing to integrations
   - Get configured integrations from IntegrationRegistry

2. `async def run_all(self) -> IntegrationResults`:
   - Get configured integrations from registry
   - If no integrations configured, return empty IntegrationResults (silent skip)
   - Run all integrations in parallel using `asyncio.gather(return_exceptions=True)`
   - Convert results to IntegrationResults with IntegrationSections

3. `async def _run_one(self, integration: Integration) -> IntegrationResult`:
   - Get or create circuit breaker for this integration
   - Check if circuit is open (fast path - skip immediately)
   - Wrap fetch call with:
     - `asyncio.wait_for(timeout=INTEGRATION_TIMEOUT)`
     - Circuit breaker decorator
   - Handle exceptions:
     - `asyncio.TimeoutError`: return failure with "timeout" error
     - `pybreaker.CircuitBreakerError`: return failure with "circuit_open" error (WARNING log)
     - Other exceptions: return failure with str(e) error (ERROR log)

4. `_result_to_section(self, result: IntegrationResult) -> IntegrationSection`:
   - Convert IntegrationResult to IntegrationSection for report
   - Map integration name to display_name (can be enhanced later)
   - Set error_message to "Unable to fetch data" on failure per CONTEXT.md

**Update __init__.py:**
Add `IntegrationRunner` to exports

Key pattern from RESEARCH.md:
```python
results = await asyncio.gather(
    *[self._run_one(i) for i in integrations],
    return_exceptions=True,  # Critical for isolation
)
```

This ensures INTG-02: One integration failing does not prevent others from running.
  </action>
  <verify>
    python -c "from unifi_scanner.integrations import IntegrationRunner; print('IntegrationRunner importable')"
  </verify>
  <done>
    IntegrationRunner runs integrations in parallel with circuit breakers and 30s timeout
  </done>
</task>

</tasks>

<verification>
```bash
# Verify all imports work
python -c "
from unifi_scanner.integrations import (
    Integration,
    IntegrationResult,
    IntegrationRunner,
    IntegrationRegistry,
)
print('All integration types importable')
"

# Verify circuit breaker configuration
python -c "
from unifi_scanner.integrations.runner import (
    create_circuit_breaker,
    INTEGRATION_TIMEOUT,
    CIRCUIT_FAIL_MAX,
    CIRCUIT_RESET_TIMEOUT,
)
cb = create_circuit_breaker('test')
assert cb.fail_max == 3, 'fail_max should be 3'
assert cb.reset_timeout == 60, 'reset_timeout should be 60'
assert INTEGRATION_TIMEOUT == 30, 'timeout should be 30s'
print('Circuit breaker config correct')
"

# Run tests to verify nothing broke
pytest tests/ -v --tb=short
```
</verification>

<success_criteria>
1. IntegrationRunner class created with run_all() and _run_one() methods
2. Circuit breakers created per integration with fail_max=3, reset_timeout=60
3. Parallel execution uses asyncio.gather with return_exceptions=True
4. Timeout of 30 seconds applied to each integration
5. CircuitBreakerError, TimeoutError, and general exceptions handled gracefully
6. Logging: WARNING for circuit open, ERROR for unexpected exceptions
7. Empty IntegrationResults returned when no integrations configured (silent skip)
</success_criteria>

<output>
After completion, create `.planning/phases/10-integration-infrastructure/10-02-SUMMARY.md`
</output>
