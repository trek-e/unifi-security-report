---
phase: 01-foundation-api-connection
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - src/unifi_scanner/api/client.py
  - src/unifi_scanner/api/session.py
  - src/unifi_scanner/health.py
  - src/unifi_scanner/__main__.py
autonomous: true
user_setup:
  - service: unifi_controller
    why: "API authentication"
    env_vars:
      - name: UNIFI_HOST
        source: "Your UniFi Controller IP or hostname"
      - name: UNIFI_USERNAME
        source: "Local admin username (not cloud SSO)"
      - name: UNIFI_PASSWORD
        source: "Local admin password"
    dashboard_config:
      - task: "Create local admin account if using cloud SSO"
        location: "UniFi Console > Admins & Users > Add Admin (Local)"

must_haves:
  truths:
    - "Service re-authenticates automatically on session expiration"
    - "Service uses fresh authentication each poll cycle"
    - "Health check file reflects current connection status"
    - "--test flag verifies config and connection, then exits"
    - "Startup banner shows version, device type, site, poll interval"
  artifacts:
    - path: "src/unifi_scanner/api/session.py"
      provides: "Session management with retry logic"
      contains: "retry"
    - path: "src/unifi_scanner/health.py"
      provides: "File-based health check"
      contains: "update_health_status"
  key_links:
    - from: "src/unifi_scanner/api/client.py"
      to: "src/unifi_scanner/api/session.py"
      via: "uses retry decorator on requests"
      pattern: "@retry"
    - from: "src/unifi_scanner/__main__.py"
      to: "src/unifi_scanner/health.py"
      via: "updates health status"
      pattern: "update_health_status"
    - from: "src/unifi_scanner/__main__.py"
      to: "src/unifi_scanner/api/client.py"
      via: "creates UnifiClient and connects"
      pattern: "UnifiClient"
---

<objective>
Implement session management with automatic re-authentication, exponential backoff retry logic, file-based health checks, and complete the CLI with --test mode and startup banner.

Purpose: Reliable session handling ensures the service runs unattended without manual intervention. Health checks enable Docker container monitoring. The startup banner provides operational visibility.

Output: Production-ready service entry point with connection test mode, health monitoring, and resilient API operations.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-api-connection/01-CONTEXT.md
@.planning/phases/01-foundation-api-connection/01-RESEARCH.md
@.planning/phases/01-foundation-api-connection/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement retry logic with exponential backoff</name>
  <files>
    src/unifi_scanner/api/session.py
    src/unifi_scanner/api/client.py
  </files>
  <action>
Create src/unifi_scanner/api/session.py with:

Import tenacity: retry, stop_after_attempt, wait_exponential, retry_if_exception_type, before_sleep_log

Create retry decorator factory:
def create_retry_decorator(max_retries: int, logger):
    """Create tenacity retry decorator with exponential backoff."""
    return retry(
        stop=stop_after_attempt(max_retries),
        wait=wait_exponential(multiplier=1, min=1, max=60),
        retry=retry_if_exception_type((httpx.ConnectError, httpx.TimeoutException)),
        before_sleep=before_sleep_log(logger, logging.WARNING),
        reraise=True
    )

Create session-aware request function:
def request_with_session_check(
    client: UnifiClient,
    method: str,
    endpoint: str,
    **kwargs
) -> httpx.Response:
    """Make request, re-authenticate on 401."""
    response = client._raw_request(method, endpoint, **kwargs)

    if response.status_code == 401:
        # Session expired - re-authenticate
        logger.info("Session expired, re-authenticating")
        client._reauthenticate()
        response = client._raw_request(method, endpoint, **kwargs)

    return response

Update src/unifi_scanner/api/client.py:
- Add _raw_request() method (current _request logic without retry)
- Add _reauthenticate() method that calls authenticate() again
- Update _request() to use request_with_session_check
- Apply retry decorator to connect() method
- Store max_retries from settings
- Log retry attempts at WARNING level

Per CONTEXT.md: Fresh authentication each poll, but handle mid-poll session expiry.
  </action>
  <verify>
    - python -c "from unifi_scanner.api.session import create_retry_decorator; print('Session module loads')"
    - Verify tenacity is used (not hand-rolled backoff)
  </verify>
  <done>Retry decorator uses tenacity with exponential backoff, 401 triggers re-authentication</done>
</task>

<task type="auto">
  <name>Task 2: Implement file-based health check</name>
  <files>
    src/unifi_scanner/health.py
  </files>
  <action>
Create src/unifi_scanner/health.py with:

HEALTH_FILE constant: Path("/tmp/unifi-scanner-health")

class HealthStatus(Enum):
    STARTING = "starting"
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"

def update_health_status(
    status: HealthStatus,
    details: dict | None = None
) -> None:
    """Write health status to file for Docker healthcheck."""
    health_data = {
        "status": status.value,
        "timestamp": datetime.utcnow().isoformat(),
        "details": details or {}
    }
    HEALTH_FILE.write_text(json.dumps(health_data))

def get_health_status() -> dict | None:
    """Read current health status. Returns None if file doesn't exist."""
    if not HEALTH_FILE.exists():
        return None
    return json.loads(HEALTH_FILE.read_text())

def clear_health_status() -> None:
    """Remove health file on shutdown."""
    HEALTH_FILE.unlink(missing_ok=True)

Add docstring with example Docker HEALTHCHECK command:
# HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
#   CMD python -c "import json; h=json.loads(open('/tmp/unifi-scanner-health').read()); exit(0 if h['status']=='healthy' else 1)"
  </action>
  <verify>
    - python -c "from unifi_scanner.health import update_health_status, HealthStatus; update_health_status(HealthStatus.HEALTHY, {'test': True}); print(open('/tmp/unifi-scanner-health').read())"
    - File should contain JSON with status: "healthy"
  </verify>
  <done>Health status written to /tmp/unifi-scanner-health, readable by Docker healthcheck</done>
</task>

<task type="auto">
  <name>Task 3: Complete CLI with --test mode and startup banner</name>
  <files>
    src/unifi_scanner/__main__.py
  </files>
  <action>
Update src/unifi_scanner/__main__.py with complete implementation:

Add imports:
- from unifi_scanner import __version__
- from unifi_scanner.config import load_config
- from unifi_scanner.logging import configure_logging
- from unifi_scanner.api import UnifiClient
- from unifi_scanner.api.exceptions import AuthenticationError, ConnectionError
- from unifi_scanner.health import update_health_status, clear_health_status, HealthStatus

Exit code constants (already added in 01-01):
EXIT_SUCCESS = 0
EXIT_CONFIG_ERROR = 1
EXIT_CONNECTION_ERROR = 2
EXIT_AUTH_ERROR = 3

def print_banner(config, client: UnifiClient | None = None):
    """Print startup banner with version and config summary."""
    lines = [
        f"UniFi Scanner v{__version__}",
        f"=" * 40,
    ]
    if client and client.device_type:
        lines.append(f"Controller: {client.device_type.value}")
        lines.append(f"Base URL: {client.base_url}")
    lines.append(f"Poll Interval: {config.poll_interval}s")
    lines.append(f"Log Level: {config.log_level}")
    lines.append(f"Log Format: {config.log_format}")
    lines.append("=" * 40)
    print("\n".join(lines))

def main():
    parser = argparse.ArgumentParser(description="UniFi log scanner and analyzer")
    parser.add_argument("--test", action="store_true", help="Test configuration and connection, then exit")
    parser.add_argument("--version", action="version", version=f"%(prog)s {__version__}")
    args = parser.parse_args()

    # Load config (exits on error)
    config = load_config()
    configure_logging(config.log_format, config.log_level)
    logger = structlog.get_logger()

    if args.test:
        # Test mode: verify config and connection
        update_health_status(HealthStatus.STARTING)
        try:
            with UnifiClient(config) as client:
                site = client.select_site(config.site)
                print_banner(config, client)
                print(f"Site: {site}")
                print("Configuration and connection: OK")
                update_health_status(HealthStatus.HEALTHY, {"site": site})
                return EXIT_SUCCESS
        except ConnectionError as e:
            logger.error("Connection failed", error=str(e))
            update_health_status(HealthStatus.UNHEALTHY, {"error": str(e)})
            return EXIT_CONNECTION_ERROR
        except AuthenticationError as e:
            logger.error("Authentication failed", error=str(e))
            update_health_status(HealthStatus.UNHEALTHY, {"error": str(e)})
            return EXIT_AUTH_ERROR
        finally:
            clear_health_status()

    # Normal mode (placeholder for Phase 5 - scheduling)
    print_banner(config)
    logger.info("UniFi Scanner starting", version=__version__)
    update_health_status(HealthStatus.STARTING)

    # TODO: Phase 5 will add scheduling loop here
    logger.info("Service initialization complete. Scheduling not yet implemented.")

    return EXIT_SUCCESS

if __name__ == "__main__":
    sys.exit(main())

Handle KeyboardInterrupt at top level with clean exit.
  </action>
  <verify>
    - unifi-scanner --version
    - unifi-scanner --help
    - Create valid config and run: unifi-scanner --test (will fail to connect without real controller, but should show config loaded)
  </verify>
  <done>--test mode verifies config and connection, startup banner shows version/device/site/interval, exit codes are meaningful</done>
</task>

</tasks>

<verification>
Overall plan verification:
1. `unifi-scanner --version` shows version
2. `unifi-scanner --help` shows all options
3. `unifi-scanner --test` with valid config attempts connection and exits with appropriate code
4. Health file created at /tmp/unifi-scanner-health
5. Retry logic uses tenacity exponential backoff
6. 401 response triggers re-authentication
7. Startup banner shows version, device type (after connect), poll interval
8. Exit codes: 0=success, 1=config error, 2=connection error, 3=auth error
</verification>

<success_criteria>
- --test flag verifies config and connection, then exits with appropriate code
- Exponential backoff on connection failures (1s, 2s, 4s... max 60s)
- 401 response triggers automatic re-authentication
- Health status file updated for Docker healthcheck
- Startup banner shows: version, detected device type, site, poll interval
- Exit codes are meaningful and documented
- Service handles KeyboardInterrupt gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-api-connection/01-04-SUMMARY.md`
</output>
