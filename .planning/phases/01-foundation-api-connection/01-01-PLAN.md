---
phase: 01-foundation-api-connection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/unifi_scanner/__init__.py
  - src/unifi_scanner/__main__.py
  - src/unifi_scanner/config/__init__.py
  - src/unifi_scanner/config/settings.py
  - src/unifi_scanner/config/loader.py
  - src/unifi_scanner/logging.py
  - unifi-scanner.example.yaml
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Service loads configuration from YAML file"
    - "Environment variables override YAML values"
    - "Service fails fast with all validation errors at once"
    - "Docker secrets pattern (_FILE suffix) works for password"
    - "SIGHUP reloads configuration without restart"
  artifacts:
    - path: "src/unifi_scanner/config/settings.py"
      provides: "Pydantic settings with YAML + env override"
      contains: "UnifiSettings"
    - path: "src/unifi_scanner/config/loader.py"
      provides: "Config loading with _FILE pattern support"
      contains: "resolve_file_secrets"
    - path: "src/unifi_scanner/logging.py"
      provides: "structlog configuration"
      contains: "configure_logging"
    - path: "unifi-scanner.example.yaml"
      provides: "Documented example configuration"
      min_lines: 30
    - path: "pyproject.toml"
      provides: "Project dependencies and metadata"
      contains: "pydantic-settings"
  key_links:
    - from: "src/unifi_scanner/__main__.py"
      to: "src/unifi_scanner/config/loader.py"
      via: "load_config() call"
      pattern: "load_config"
    - from: "src/unifi_scanner/config/loader.py"
      to: "src/unifi_scanner/config/settings.py"
      via: "UnifiSettings instantiation"
      pattern: "UnifiSettings"
---

<objective>
Establish project scaffolding with a layered configuration system supporting YAML base config, environment variable overrides, Docker secrets pattern, and hot reload via SIGHUP.

Purpose: Configuration is the foundation that all other components depend on. A robust config system with clear error messages enables smooth setup and operation.

Output: Working Python package structure with complete configuration management, ready for other components to import settings.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-api-connection/01-CONTEXT.md
@.planning/phases/01-foundation-api-connection/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python package structure with dependencies</name>
  <files>
    pyproject.toml
    src/unifi_scanner/__init__.py
    src/unifi_scanner/__main__.py
  </files>
  <action>
Create pyproject.toml with:
- name: unifi-scanner
- Python 3.11+ requirement
- Dependencies: pydantic>=2.11, pydantic-settings>=2.0, httpx>=0.27, structlog>=25.5, tenacity>=8.3, pyyaml>=6.0, python-dotenv>=1.0, orjson>=3.10
- Build system using hatchling or setuptools
- Entry point: unifi-scanner = "unifi_scanner.__main__:main"

Create src/unifi_scanner/__init__.py with:
- __version__ = "0.1.0"
- Package docstring explaining purpose

Create src/unifi_scanner/__main__.py with:
- main() function that will be entry point
- Imports load_config from config.loader
- Imports configure_logging from logging
- --test flag for connection test mode (exit 0 if config valid, non-zero otherwise)
- Startup banner with version, detected config file path
- Signal handler for SIGHUP that calls config reload
- Basic argument parsing with argparse

Use src layout (not flat) for proper package isolation.
  </action>
  <verify>
    - cd /Users/trekkie/projects/unifi_scanner && pip install -e .
    - python -c "from unifi_scanner import __version__; print(__version__)"
    - unifi-scanner --help shows usage
  </verify>
  <done>Package installs in editable mode, version imports correctly, CLI shows help</done>
</task>

<task type="auto">
  <name>Task 2: Implement configuration system with YAML and env override</name>
  <files>
    src/unifi_scanner/config/__init__.py
    src/unifi_scanner/config/settings.py
    src/unifi_scanner/config/loader.py
    src/unifi_scanner/logging.py
    unifi-scanner.example.yaml
  </files>
  <action>
Create src/unifi_scanner/config/settings.py with UnifiSettings class:
- Inherit from pydantic_settings.BaseSettings
- model_config with env_prefix="UNIFI_", yaml_file from CONFIG_PATH env var
- Fields from CONTEXT.md: host (required), username (required), password, port (optional, auto-detect), verify_ssl (default True), connect_timeout (default 10), max_retries (default 5), poll_interval (default 300), log_level (default INFO), log_format (default json), site (optional)
- Custom settings_customise_sources to set precedence: init > env > yaml
- Validators to ensure meaningful defaults and constraints (timeout > 0, etc.)

Create src/unifi_scanner/config/loader.py with:
- resolve_file_secrets() function: scans env for UNIFI_*_FILE, reads file contents
- load_config() function: applies file secrets, creates UnifiSettings, catches ValidationError
- On validation error: collect ALL errors and log them at once, then exit(1)
- handle_sighup() function to reload config
- Thread-safe config access with threading.Lock

Create src/unifi_scanner/logging.py with configure_logging():
- Accept log_format ("json" or "text") and log_level
- For json: use structlog with JSONRenderer, TimeStamper(fmt="iso")
- For text: use structlog with ConsoleRenderer(colors=True)
- Configure stdlib logging to route through structlog
- Never log password or sensitive fields

Create unifi-scanner.example.yaml with ALL options documented:
- Comments explaining each field
- host, username, password placeholders
- All optional fields with their defaults commented
- Docker secrets note for password_file pattern

Create src/unifi_scanner/config/__init__.py exporting UnifiSettings, load_config
  </action>
  <verify>
    - Create test config: echo "host: 192.168.1.1\nusername: admin\npassword: test" > /tmp/test-config.yaml
    - CONFIG_PATH=/tmp/test-config.yaml python -c "from unifi_scanner.config import load_config; c = load_config(); print(c.host)"
    - UNIFI_HOST=override.local CONFIG_PATH=/tmp/test-config.yaml python -c "from unifi_scanner.config import load_config; c = load_config(); print(c.host)"
    - Second command should print "override.local" (env overrides yaml)
  </verify>
  <done>Config loads from YAML, env vars override YAML values, example YAML is comprehensive</done>
</task>

<task type="auto">
  <name>Task 3: Implement fail-fast validation and meaningful exit codes</name>
  <files>
    src/unifi_scanner/__main__.py
    src/unifi_scanner/config/loader.py
  </files>
  <action>
Update src/unifi_scanner/config/loader.py:
- Wrap UnifiSettings() in try/except for pydantic.ValidationError
- When validation fails: iterate error.errors(), format each with field path and message
- Log ALL errors at once using structlog, then sys.exit(1)
- Create custom ConfigurationError exception for non-validation config issues

Update src/unifi_scanner/__main__.py:
- Define exit codes as constants: EXIT_SUCCESS=0, EXIT_CONFIG_ERROR=1, EXIT_CONNECTION_ERROR=2, EXIT_AUTH_ERROR=3
- On startup: load config, if fails exit with EXIT_CONFIG_ERROR
- If --test flag: load config, print "Configuration valid", exit(0)
- Add startup banner showing: version, config file path (or "env-only" if no yaml), log level
- Handle KeyboardInterrupt gracefully with clean exit message

Ensure error messages are user-friendly at INFO level:
- "Configuration error: 'host' is required. Set UNIFI_HOST or add 'host:' to config file."
- "Configuration error: 'port' must be between 1-65535, got: 99999"
  </action>
  <verify>
    - CONFIG_PATH=/nonexistent.yaml unifi-scanner --test 2>&1 | grep -i "error"
    - echo "username: admin" > /tmp/bad-config.yaml && CONFIG_PATH=/tmp/bad-config.yaml unifi-scanner --test; echo "Exit code: $?"
    - Exit code should be 1 (config error)
    - Should show error about missing 'host' field
  </verify>
  <done>Invalid config shows all errors at once, exits with code 1, messages are actionable</done>
</task>

</tasks>

<verification>
Overall plan verification:
1. `pip install -e .` completes without error
2. `unifi-scanner --help` shows CLI options
3. `unifi-scanner --test` with valid config exits 0
4. `unifi-scanner --test` with invalid config exits 1 and shows all errors
5. Environment variables override YAML config values
6. Example YAML file is comprehensive and well-documented
7. Log output format switches between JSON and text based on config
</verification>

<success_criteria>
- Project installs as editable package
- Configuration loads from YAML with env var overrides
- Docker secrets _FILE pattern supported
- All validation errors reported at once
- Exit codes are meaningful (1=config error)
- Startup banner displays version and config summary
- structlog configured for JSON (production) or text (development)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-api-connection/01-01-SUMMARY.md`
</output>
