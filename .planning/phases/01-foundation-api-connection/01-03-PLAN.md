---
phase: 01-foundation-api-connection
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/unifi_scanner/api/__init__.py
  - src/unifi_scanner/api/client.py
  - src/unifi_scanner/api/auth.py
  - src/unifi_scanner/api/endpoints.py
  - src/unifi_scanner/api/exceptions.py
autonomous: true

must_haves:
  truths:
    - "Service auto-detects device type (UDM vs self-hosted) on connection"
    - "Service authenticates with LOCAL admin credentials"
    - "Service uses correct API prefix based on device type"
    - "Service discovers available sites and selects appropriately"
    - "Connection errors include helpful troubleshooting hints"
  artifacts:
    - path: "src/unifi_scanner/api/client.py"
      provides: "UniFi API client with device detection"
      contains: "class UnifiClient"
    - path: "src/unifi_scanner/api/auth.py"
      provides: "Authentication logic for both device types"
      contains: "authenticate"
    - path: "src/unifi_scanner/api/endpoints.py"
      provides: "API endpoint definitions"
      contains: "ENDPOINTS"
    - path: "src/unifi_scanner/api/exceptions.py"
      provides: "Custom exceptions for API errors"
      contains: "AuthenticationError"
  key_links:
    - from: "src/unifi_scanner/api/client.py"
      to: "src/unifi_scanner/api/auth.py"
      via: "authenticate call on connection"
      pattern: "authenticate"
    - from: "src/unifi_scanner/api/client.py"
      to: "src/unifi_scanner/config/settings.py"
      via: "uses UnifiSettings for config"
      pattern: "UnifiSettings"
    - from: "src/unifi_scanner/api/auth.py"
      to: "src/unifi_scanner/api/endpoints.py"
      via: "uses endpoint definitions"
      pattern: "ENDPOINTS"
---

<objective>
Create UniFi API client with automatic device type detection, authentication for both UDM and self-hosted controllers, and site discovery.

Purpose: The API client is the primary interface to UniFi controllers. Automatic device detection ensures the service works across different UniFi deployments without manual configuration.

Output: Working UnifiClient class that can detect device type, authenticate, and list sites on any UniFi controller type.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-api-connection/01-CONTEXT.md
@.planning/phases/01-foundation-api-connection/01-RESEARCH.md
@.planning/phases/01-foundation-api-connection/01-01-SUMMARY.md
@.planning/phases/01-foundation-api-connection/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API exceptions and endpoint definitions</name>
  <files>
    src/unifi_scanner/api/__init__.py
    src/unifi_scanner/api/exceptions.py
    src/unifi_scanner/api/endpoints.py
  </files>
  <action>
Create src/unifi_scanner/api/exceptions.py with custom exceptions:
- UnifiAPIError(Exception): Base exception for all API errors
- AuthenticationError(UnifiAPIError): Authentication failed (exit code 3)
  - Include helpful message: "Ensure you're using a LOCAL admin account, not cloud SSO"
- ConnectionError(UnifiAPIError): Cannot reach controller (exit code 2)
  - Include hint: "Is the UniFi Controller running? Check network connectivity."
- DeviceDetectionError(UnifiAPIError): Cannot determine device type
- SiteNotFoundError(UnifiAPIError): Specified site doesn't exist
- MultipleSitesError(UnifiAPIError): Multiple sites found, none specified
  - Include list of available sites in message

Create src/unifi_scanner/api/endpoints.py with endpoint definitions:
- Define as dataclass or dict structure
- UDM_PRO endpoints:
  - login: /api/auth/login
  - logout: /api/auth/logout
  - sites: /proxy/network/api/self/sites
  - self: /proxy/network/api/self
  - status: /status (no auth required)
- SELF_HOSTED endpoints:
  - login: /api/login
  - logout: /api/logout
  - sites: /api/self/sites
  - self: /api/self
  - status: /status

Create function get_endpoints(device_type: DeviceType) -> dict that returns correct endpoints

Create src/unifi_scanner/api/__init__.py exporting UnifiClient, exceptions
  </action>
  <verify>
    - python -c "from unifi_scanner.api.exceptions import AuthenticationError; raise AuthenticationError('test')"
    - python -c "from unifi_scanner.api.endpoints import get_endpoints; from unifi_scanner.models import DeviceType; print(get_endpoints(DeviceType.UDM_PRO)['login'])"
    - Should print "/api/auth/login"
  </verify>
  <done>Custom exceptions exist with helpful messages, endpoints defined for both device types</done>
</task>

<task type="auto">
  <name>Task 2: Implement device detection and authentication</name>
  <files>
    src/unifi_scanner/api/auth.py
  </files>
  <action>
Create src/unifi_scanner/api/auth.py with:

detect_device_type(host: str, port: int | None, verify_ssl: bool, timeout: int) -> tuple[DeviceType, int]:
  - If port specified, only try that port
  - Otherwise try ports in order: 443, 8443, 11443
  - For each port, GET /status (no auth required)
  - Analyze response to determine device type:
    - Port 443 or response contains UniFi OS indicators -> UDM_PRO
    - Port 8443 or 11443 with different response -> SELF_HOSTED
  - Return (device_type, detected_port)
  - On all ports failing: raise ConnectionError with helpful message

authenticate(client: httpx.Client, base_url: str, device_type: DeviceType, username: str, password: str) -> None:
  - Get correct login endpoint from get_endpoints(device_type)
  - POST with {"username": username, "password": password}
  - Handle response:
    - 200: Success, session cookie stored in client
    - 401/403: Raise AuthenticationError with LOCAL admin hint
    - Other: Raise UnifiAPIError with status code
  - Log successful auth at INFO level (without password)

logout(client: httpx.Client, base_url: str, device_type: DeviceType) -> None:
  - POST to logout endpoint
  - Ignore errors (best-effort logout)

Use httpx.Client (sync) for all requests. The client maintains cookie state automatically.
Do NOT log password at any level. Log username at DEBUG only.
  </action>
  <verify>
    - python -c "from unifi_scanner.api.auth import detect_device_type, authenticate; print('Auth module loads')"
    - Check that auth.py contains the functions with correct signatures
  </verify>
  <done>Device detection tries multiple ports, authentication works for both device types, errors include helpful hints</done>
</task>

<task type="auto">
  <name>Task 3: Implement UnifiClient with site discovery</name>
  <files>
    src/unifi_scanner/api/client.py
    src/unifi_scanner/api/__init__.py
  </files>
  <action>
Create src/unifi_scanner/api/client.py with UnifiClient class:

class UnifiClient:
    def __init__(self, settings: UnifiSettings):
        - Store settings reference
        - Initialize httpx.Client with verify=settings.verify_ssl, timeout=settings.connect_timeout
        - Initialize device_type, base_url, api_prefix as None (set on connect)
        - Initialize _authenticated = False

    def connect(self) -> None:
        - Call detect_device_type() to find controller
        - Set self.base_url = f"https://{host}:{port}"
        - Set self.device_type and self.api_prefix based on detection
        - Call authenticate()
        - Set _authenticated = True
        - Log startup info: device type, base URL, at INFO level

    def disconnect(self) -> None:
        - Call logout() if authenticated
        - Close httpx.Client
        - Set _authenticated = False

    def get_sites(self) -> list[dict]:
        - GET sites endpoint
        - Parse response, return list of site dicts
        - Each site has 'name', 'desc', '_id'

    def select_site(self, site_name: str | None) -> str:
        - Get sites list
        - If site_name specified: find matching site or raise SiteNotFoundError
        - If only one site: use it automatically
        - If multiple sites and none specified: raise MultipleSitesError with list
        - Return selected site name
        - Log selected site at INFO level

    def _request(self, method: str, endpoint: str, **kwargs) -> httpx.Response:
        - Internal method for API requests
        - Prepend api_prefix to endpoint
        - Handle common response codes
        - Return response for caller to process

    Context manager support:
    def __enter__(self) -> "UnifiClient": connect and return self
    def __exit__(...): disconnect

Update src/unifi_scanner/api/__init__.py to export UnifiClient
  </action>
  <verify>
    - python -c "from unifi_scanner.api import UnifiClient; from unifi_scanner.config import UnifiSettings; print('Client imports work')"
    - Verify UnifiClient has connect, disconnect, get_sites, select_site methods
  </verify>
  <done>UnifiClient detects device type, authenticates, discovers sites, works as context manager</done>
</task>

</tasks>

<verification>
Overall plan verification:
1. UnifiClient imports without error
2. Device detection logic handles UDM (port 443) and self-hosted (port 8443, 11443)
3. Authentication uses correct endpoints per device type
4. Site discovery returns available sites
5. MultipleSitesError lists available sites when selection needed
6. All error messages include troubleshooting hints
7. No sensitive data (passwords) logged at any level
</verification>

<success_criteria>
- Device type auto-detected by trying ports 443, 8443, 11443
- UDM uses /api/auth/login and /proxy/network prefix
- Self-hosted uses /api/login and no prefix
- Authentication works with LOCAL admin credentials
- Site auto-selected if only one, error with list if multiple
- Connection errors include helpful hints for non-experts
- Client works as context manager (with statement)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-api-connection/01-03-SUMMARY.md`
</output>
