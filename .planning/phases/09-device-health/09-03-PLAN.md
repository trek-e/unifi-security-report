---
phase: 09-device-health
plan: 03
type: tdd
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/unifi_scanner/analysis/device_health/thresholds.py
  - src/unifi_scanner/analysis/device_health/analyzer.py
  - src/unifi_scanner/analysis/device_health/__init__.py
  - tests/test_device_health_analyzer.py
autonomous: true

must_haves:
  truths:
    - "Analyzer generates temperature warnings when devices exceed 80C threshold"
    - "Analyzer generates critical alerts when devices exceed 90C threshold"
    - "Analyzer flags devices with uptime > 90 days as needing restart"
    - "Analyzer alerts on CPU > 80% and memory > 85%"
    - "Healthy devices appear in summary without findings"
  artifacts:
    - path: "src/unifi_scanner/analysis/device_health/analyzer.py"
      provides: "DeviceHealthAnalyzer class"
      min_lines: 100
    - path: "src/unifi_scanner/analysis/device_health/thresholds.py"
      provides: "HealthThresholds dataclass with defaults"
      min_lines: 25
    - path: "tests/test_device_health_analyzer.py"
      provides: "Analyzer threshold and edge case tests"
      min_lines: 100
  key_links:
    - from: "DeviceHealthAnalyzer.analyze_devices"
      to: "DeviceHealthResult"
      via: "returns analysis result"
      pattern: "def analyze_devices.*DeviceHealthResult"
    - from: "analyzer"
      to: "thresholds"
      via: "uses HealthThresholds for comparison"
      pattern: "HealthThresholds"
---

<objective>
Create DeviceHealthAnalyzer with configurable thresholds using TDD approach.

Purpose: Analyze device statistics and generate health findings when metrics exceed safe thresholds. Following Phase 8's IPSAnalyzer pattern for dedicated analysis with dataclass results.

Output: DeviceHealthAnalyzer class that processes DeviceStats list and produces DeviceHealthResult with categorized findings.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-device-health/09-RESEARCH.md

# Dependency from Plan 01
@src/unifi_scanner/analysis/device_health/models.py

# Reference Phase 8 analyzer pattern
@src/unifi_scanner/analysis/ips/analyzer.py
</context>

<feature>
  <name>Device Health Analyzer</name>
  <files>
    src/unifi_scanner/analysis/device_health/thresholds.py
    src/unifi_scanner/analysis/device_health/analyzer.py
    src/unifi_scanner/analysis/device_health/__init__.py
    tests/test_device_health_analyzer.py
  </files>
  <behavior>
    HealthThresholds (frozen dataclass):
    - temp_warning: 80.0 (Celsius, fan threshold)
    - temp_critical: 90.0 (thermal throttling risk)
    - cpu_warning: 80 (percent)
    - cpu_critical: 95 (percent)
    - memory_warning: 85 (percent)
    - memory_critical: 95 (percent)
    - uptime_warning: 90 (days)
    - uptime_critical: 180 (days)

    DeviceHealthAnalyzer.analyze_devices(devices: List[DeviceStats]) -> DeviceHealthResult:

    Test cases for temperature:
    - Device at 75C -> no finding (below warning)
    - Device at 82C -> warning finding, severity MEDIUM
    - Device at 92C -> critical finding, severity SEVERE
    - Device with no temperature data -> no temperature finding

    Test cases for CPU:
    - CPU at 50% -> no finding
    - CPU at 82% -> warning finding
    - CPU at 96% -> critical finding

    Test cases for memory:
    - Memory at 70% -> no finding
    - Memory at 87% -> warning finding
    - Memory at 96% -> critical finding

    Test cases for uptime:
    - Uptime 30 days -> no finding
    - Uptime 95 days -> warning finding (recommend restart)
    - Uptime 200 days -> critical finding (strongly recommend restart)

    Test cases for result structure:
    - Empty device list -> empty result with zeros
    - 3 devices, all healthy -> 3 summaries, 0 findings, healthy_devices=3
    - 1 critical, 1 warning, 1 healthy -> correct counts, findings sorted by severity
    - Device with multiple issues (hot AND high CPU) -> multiple findings for same device

    Remediation templates:
    - Temperature: check ventilation, reduce load, consider cooling
    - CPU: identify high-usage processes, check for runaway tasks
    - Memory: restart device, check for memory leaks
    - Uptime: schedule restart during maintenance window
  </behavior>
  <implementation>
    1. Create thresholds.py with HealthThresholds frozen dataclass
    2. Create analyzer.py with DeviceHealthAnalyzer class:
       - __init__ accepts optional HealthThresholds (defaults to DEFAULT_THRESHOLDS)
       - analyze_devices method processes list of DeviceStats
       - Internal methods: _check_temperature, _check_cpu, _check_memory, _check_uptime
       - Each check method creates DeviceHealthFinding if threshold exceeded
       - Collects all findings and builds DeviceHealthResult
    3. Update __init__.py to export DeviceHealthAnalyzer, HealthThresholds
    4. Tests verify all threshold boundaries and edge cases
  </implementation>
</feature>

<verification>
```bash
# Run analyzer tests
python -m pytest tests/test_device_health_analyzer.py -v

# Verify module exports
python -c "from unifi_scanner.analysis.device_health import DeviceHealthAnalyzer, HealthThresholds, DEFAULT_THRESHOLDS; print(f'Thresholds: temp_warning={DEFAULT_THRESHOLDS.temp_warning}C')"
```
</verification>

<success_criteria>
- All analyzer tests pass
- Temperature thresholds at 80C (warning) and 90C (critical)
- CPU thresholds at 80% (warning) and 95% (critical)
- Memory thresholds at 85% (warning) and 95% (critical)
- Uptime thresholds at 90 days (warning) and 180 days (critical)
- Findings include remediation guidance
- Result correctly counts healthy vs unhealthy devices
</success_criteria>

<output>
After completion, create `.planning/phases/09-device-health/09-03-SUMMARY.md`
</output>
