---
phase: 11-cloudflare-integration
plan: 02
type: execute
wave: 2
depends_on: [11-01]
files_modified:
  - src/unifi_scanner/integrations/cloudflare/integration.py
  - src/unifi_scanner/integrations/cloudflare/__init__.py
  - src/unifi_scanner/integrations/__init__.py
autonomous: true

must_haves:
  truths:
    - "CloudflareIntegration implements Integration Protocol"
    - "is_configured() returns True only when API token is set"
    - "validate_config() returns warning for partial config (token without account_id)"
    - "fetch() returns CloudflareData wrapped in IntegrationResult"
    - "Integration is registered with IntegrationRegistry"
  artifacts:
    - path: "src/unifi_scanner/integrations/cloudflare/integration.py"
      provides: "CloudflareIntegration class"
      min_lines: 60
    - path: "src/unifi_scanner/integrations/__init__.py"
      provides: "Import of cloudflare module to trigger registration"
      contains: "cloudflare"
  key_links:
    - from: "src/unifi_scanner/integrations/cloudflare/integration.py"
      to: "IntegrationRegistry"
      via: "IntegrationRegistry.register()"
      pattern: "IntegrationRegistry\\.register"
    - from: "src/unifi_scanner/integrations/cloudflare/integration.py"
      to: "CloudflareClient"
      via: "Client instantiation in fetch()"
      pattern: "CloudflareClient\\("
---

<objective>
Create CloudflareIntegration implementing the Integration Protocol from Phase 10.

Purpose: Wires CloudflareClient into the integration infrastructure, enabling automatic execution during report generation with circuit breaker protection.

Output: Fully functional CloudflareIntegration registered with IntegrationRegistry, ready to be run by IntegrationRunner.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-cloudflare-integration/11-RESEARCH.md
@.planning/phases/11-cloudflare-integration/11-CONTEXT.md
@.planning/phases/11-cloudflare-integration/11-01-SUMMARY.md
@src/unifi_scanner/integrations/base.py
@src/unifi_scanner/integrations/registry.py
@src/unifi_scanner/integrations/runner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CloudflareIntegration class</name>
  <files>
    src/unifi_scanner/integrations/cloudflare/integration.py
  </files>
  <action>
Create `integration.py` implementing the Integration Protocol:

```python
"""CloudflareIntegration implementing the Integration Protocol.

Provides WAF events, DNS analytics, and tunnel status for the security report.
Registered with IntegrationRegistry at module import time.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Optional

import structlog

from unifi_scanner.integrations.base import Integration, IntegrationResult
from unifi_scanner.integrations.cloudflare.client import CloudflareClient
from unifi_scanner.integrations.cloudflare.models import CloudflareData
from unifi_scanner.integrations.registry import IntegrationRegistry

if TYPE_CHECKING:
    from unifi_scanner.config.settings import UnifiSettings

log = structlog.get_logger()


class CloudflareIntegration:
    """Cloudflare integration for WAF, DNS, and tunnel data.

    Implements the Integration Protocol from Phase 10 infrastructure.
    Automatically registered with IntegrationRegistry at module import.

    Configuration:
        - CLOUDFLARE_API_TOKEN (required): Scoped API token
        - CLOUDFLARE_ACCOUNT_ID (optional): Account ID for tunnels/DNS

    Per CONTEXT.md:
        - API Token only, not legacy global API key
        - Silent skip if not configured
        - Warning if partial config (token without account_id for tunnels)
    """

    def __init__(self, settings: "UnifiSettings") -> None:
        """Initialize with settings.

        Args:
            settings: Application settings containing Cloudflare credentials.
        """
        self._settings = settings
        self._token = getattr(settings, "cloudflare_api_token", None)
        self._account_id = getattr(settings, "cloudflare_account_id", None)

    @property
    def name(self) -> str:
        """Unique integration identifier."""
        return "cloudflare"

    def is_configured(self) -> bool:
        """Check if integration has required credentials.

        Per CONTEXT.md: API token is the only required credential.
        Account ID is optional (can be auto-discovered from zones).

        Returns:
            True if API token is set.
        """
        return bool(self._token)

    def validate_config(self) -> Optional[str]:
        """Validate configuration completeness.

        Per CONTEXT.md: Warn if partial config.
        Token without account_id means tunnels might not work if zone
        discovery fails to find account ID.

        Returns:
            Warning message if partial config, None otherwise.
        """
        if self._token and not self._account_id:
            return (
                "CLOUDFLARE_ACCOUNT_ID not set. "
                "Tunnel status may not be available if account ID cannot be auto-discovered."
            )
        return None

    async def fetch(self) -> IntegrationResult:
        """Fetch data from Cloudflare APIs.

        Creates CloudflareClient and fetches WAF events, DNS analytics,
        and tunnel status. Lookback uses initial_lookback_hours from settings.

        Returns:
            IntegrationResult with CloudflareData or error message.

        Raises:
            Exception: Any error from API calls (caught by IntegrationRunner).
        """
        if not self._token:
            return IntegrationResult(
                name=self.name,
                success=False,
                error="Not configured",
            )

        # Get lookback from settings (same as report window)
        lookback_hours = getattr(self._settings, "initial_lookback_hours", 24)

        log.info(
            "cloudflare_fetch_start",
            lookback_hours=lookback_hours,
            has_account_id=bool(self._account_id),
        )

        client = CloudflareClient(
            token=self._token,
            account_id=self._account_id,
        )

        data = await client.fetch_all(lookback_hours=lookback_hours)

        log.info(
            "cloudflare_fetch_complete",
            waf_events=len(data.waf_events),
            has_dns=data.has_dns_analytics,
            tunnels=len(data.tunnels),
            zones=len(data.zones_queried),
        )

        # Convert CloudflareData to dict for IntegrationResult.data
        return IntegrationResult(
            name=self.name,
            success=True,
            data=self._data_to_dict(data),
        )

    def _data_to_dict(self, data: CloudflareData) -> dict:
        """Convert CloudflareData to dict for template rendering.

        Formats data for Jinja2 template consumption with helper values.
        """
        return {
            # WAF events
            "waf_events": [e.model_dump() for e in data.waf_events],
            "waf_by_source": {
                source: [e.model_dump() for e in events]
                for source, events in data.get_waf_by_source().items()
            },
            "top_blocked_ips": data.get_top_blocked_ips(10),
            "has_waf_events": data.has_waf_events,
            "waf_count": len(data.waf_events),

            # DNS analytics
            "dns_analytics": data.dns_analytics.model_dump() if data.dns_analytics else None,
            "has_dns_analytics": data.has_dns_analytics,

            # Tunnels
            "tunnels": [t.model_dump() for t in data.tunnels],
            "has_tunnels": data.has_tunnels,
            "down_tunnels": [t.model_dump() for t in data.down_tunnels],
            "has_down_tunnels": len(data.down_tunnels) > 0,

            # Metadata
            "zones_queried": data.zones_queried,
        }


# Register at module import time (per Phase 10 pattern)
IntegrationRegistry.register(CloudflareIntegration)
```
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/unifi_scanner && python -c "
from unifi_scanner.integrations.cloudflare.integration import CloudflareIntegration
from unifi_scanner.integrations.base import Integration

# Verify Protocol compliance
assert isinstance(CloudflareIntegration, type), 'Should be a class'

# Test instantiation with mock settings
class MockSettings:
    cloudflare_api_token = None
    cloudflare_account_id = None
    initial_lookback_hours = 24

integration = CloudflareIntegration(MockSettings())
print(f'name: {integration.name}')
print(f'is_configured (no token): {integration.is_configured()}')

MockSettings.cloudflare_api_token = 'test_token'
integration2 = CloudflareIntegration(MockSettings())
print(f'is_configured (with token): {integration2.is_configured()}')
print(f'validate_config (no account_id): {integration2.validate_config()}')

print('Protocol implementation verified!')
"
```
  </verify>
  <done>
CloudflareIntegration implements Integration Protocol. is_configured() works. validate_config() warns about missing account_id.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire integration into registry via imports</name>
  <files>
    src/unifi_scanner/integrations/cloudflare/__init__.py
    src/unifi_scanner/integrations/__init__.py
  </files>
  <action>
1. Update `src/unifi_scanner/integrations/cloudflare/__init__.py` to import integration (triggers registration):

```python
"""Cloudflare integration for WAF events, DNS analytics, and tunnel status."""

from unifi_scanner.integrations.cloudflare.client import CloudflareClient
from unifi_scanner.integrations.cloudflare.integration import CloudflareIntegration
from unifi_scanner.integrations.cloudflare.models import (
    CloudflareData,
    DNSAnalytics,
    TunnelStatus,
    WAFEvent,
)

__all__ = [
    "CloudflareClient",
    "CloudflareData",
    "CloudflareIntegration",
    "DNSAnalytics",
    "TunnelStatus",
    "WAFEvent",
]
```

2. Update `src/unifi_scanner/integrations/__init__.py` to import cloudflare module:

```python
"""External integrations infrastructure.

Provides the Integration Protocol, registry, and runner for optional
external integrations like Cloudflare and Cybersecure.

Importing this module triggers registration of all available integrations.
"""

# Base types and infrastructure
from unifi_scanner.integrations.base import (
    Integration,
    IntegrationResult,
    IntegrationResults,
    IntegrationSection,
)
from unifi_scanner.integrations.registry import IntegrationRegistry
from unifi_scanner.integrations.runner import IntegrationRunner

# Import integration modules to trigger registration
# Each module registers itself via IntegrationRegistry.register()
from unifi_scanner.integrations import cloudflare  # noqa: F401

__all__ = [
    "Integration",
    "IntegrationRegistry",
    "IntegrationResult",
    "IntegrationResults",
    "IntegrationRunner",
    "IntegrationSection",
]
```
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/unifi_scanner && python -c "
from unifi_scanner.integrations.registry import IntegrationRegistry

# Clear any prior registrations
IntegrationRegistry.clear()

# Import integrations module - should trigger cloudflare registration
from unifi_scanner.integrations import cloudflare

# Verify registration
class MockSettings:
    cloudflare_api_token = 'test_token'
    cloudflare_account_id = None
    initial_lookback_hours = 24

configured = IntegrationRegistry.get_configured(MockSettings())
print(f'Configured integrations: {[i.name for i in configured]}')
assert any(i.name == 'cloudflare' for i in configured), 'Cloudflare should be registered'
print('Registration verified!')
"
```
  </verify>
  <done>
CloudflareIntegration registered with IntegrationRegistry. Import chain works correctly.
  </done>
</task>

</tasks>

<verification>
1. CloudflareIntegration imports and instantiates
2. is_configured() returns False without token, True with token
3. validate_config() warns when account_id missing
4. Integration registered with IntegrationRegistry
5. `python -m pytest tests/test_integrations.py -x -q` passes
</verification>

<success_criteria>
- CloudflareIntegration class exists with name, is_configured(), validate_config(), fetch()
- Integration registered via import of cloudflare module
- IntegrationRegistry.get_configured() includes cloudflare when token set
- All integration infrastructure tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-cloudflare-integration/11-02-SUMMARY.md`
</output>
