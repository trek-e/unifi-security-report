---
phase: 11-cloudflare-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/unifi_scanner/config/settings.py
  - src/unifi_scanner/integrations/cloudflare/__init__.py
  - src/unifi_scanner/integrations/cloudflare/models.py
  - src/unifi_scanner/integrations/cloudflare/client.py
autonomous: true
user_setup:
  - service: cloudflare
    why: "API token for Cloudflare WAF, DNS, and tunnel data"
    env_vars:
      - name: CLOUDFLARE_API_TOKEN
        source: "Cloudflare Dashboard -> My Profile -> API Tokens -> Create Token"
      - name: CLOUDFLARE_ACCOUNT_ID
        source: "Cloudflare Dashboard -> any domain -> Overview (right sidebar)"
    dashboard_config:
      - task: "Create API token with permissions: Zone Analytics:Read, Account Analytics:Read, Cloudflare Tunnel:Read, Zero Trust:Read"
        location: "Cloudflare Dashboard -> My Profile -> API Tokens"

must_haves:
  truths:
    - "Cloudflare SDK is available as project dependency"
    - "Settings accept CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID"
    - "Pydantic models validate Cloudflare API responses"
    - "Client can fetch WAF events, DNS analytics, and tunnel status"
  artifacts:
    - path: "pyproject.toml"
      provides: "cloudflare>=4.3 dependency"
      contains: "cloudflare"
    - path: "src/unifi_scanner/config/settings.py"
      provides: "Cloudflare settings fields"
      contains: "cloudflare_api_token"
    - path: "src/unifi_scanner/integrations/cloudflare/models.py"
      provides: "WAFEvent, DNSAnalytics, TunnelStatus, CloudflareData models"
      min_lines: 80
    - path: "src/unifi_scanner/integrations/cloudflare/client.py"
      provides: "CloudflareClient with fetch methods"
      min_lines: 100
  key_links:
    - from: "src/unifi_scanner/integrations/cloudflare/client.py"
      to: "https://api.cloudflare.com/client/v4/graphql"
      via: "httpx POST with Bearer token"
      pattern: "Authorization.*Bearer"
---

<objective>
Create the core Cloudflare module with data models and API client.

Purpose: Establishes the foundation for Cloudflare integration - models for data validation and client for API communication. Uses official cloudflare SDK for REST (tunnels) and direct httpx for GraphQL (WAF/DNS).

Output: Working CloudflareClient that can authenticate and fetch data from Cloudflare APIs, plus settings fields for configuration.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-cloudflare-integration/11-RESEARCH.md
@.planning/phases/11-cloudflare-integration/11-CONTEXT.md
@src/unifi_scanner/config/settings.py
@src/unifi_scanner/integrations/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Cloudflare SDK and settings fields</name>
  <files>
    pyproject.toml
    src/unifi_scanner/config/settings.py
  </files>
  <action>
1. Add `cloudflare>=4.3` to dependencies in pyproject.toml (after websockets line)

2. Add Cloudflare settings fields to UnifiSettings class in settings.py:
   ```python
   # Cloudflare integration settings (optional)
   cloudflare_api_token: Optional[str] = Field(
       default=None,
       description="Cloudflare API token for WAF, DNS, and tunnel data",
   )
   cloudflare_account_id: Optional[str] = Field(
       default=None,
       description="Cloudflare account ID (required for tunnel status, auto-discovered from zones if not set)",
   )
   ```

Place after websocket_buffer_size field. These are optional - None means not configured.
  </action>
  <verify>
Run `pip install -e .` to verify dependency resolution. Import settings and check new fields exist:
```bash
cd /Users/trekkie/projects/unifi_scanner && pip install -e . && python -c "from unifi_scanner.config.settings import UnifiSettings; print('cloudflare_api_token' in UnifiSettings.model_fields)"
```
  </verify>
  <done>
cloudflare SDK installs without conflict, UnifiSettings has cloudflare_api_token and cloudflare_account_id fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Cloudflare data models</name>
  <files>
    src/unifi_scanner/integrations/cloudflare/__init__.py
    src/unifi_scanner/integrations/cloudflare/models.py
  </files>
  <action>
1. Create `src/unifi_scanner/integrations/cloudflare/` directory

2. Create `__init__.py` with public exports (leave mostly empty for now, will populate after client):
   ```python
   """Cloudflare integration for WAF events, DNS analytics, and tunnel status."""
   ```

3. Create `models.py` with Pydantic models:

```python
"""Pydantic models for Cloudflare API data.

Validates responses from Cloudflare GraphQL (WAF, DNS) and REST (tunnels) APIs.
"""

from __future__ import annotations

from datetime import datetime
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class WAFEvent(BaseModel):
    """A single WAF block event from Cloudflare.

    Represents a request blocked by Cloudflare WAF, firewall rules,
    or other security features.
    """

    timestamp: datetime = Field(description="When the event occurred")
    action: str = Field(description="Action taken (block, challenge, etc.)")
    source_ip: str = Field(description="Client IP that was blocked")
    country: str = Field(default="", description="Client country name")
    path: str = Field(default="", description="Requested URL path")
    host: str = Field(default="", description="Target hostname")
    rule_source: str = Field(description="What blocked it (waf, firewallrules, etc.)")
    rule_id: Optional[str] = Field(default=None, description="Specific rule ID if available")
    user_agent: str = Field(default="", description="Client user agent string")
    zone_name: str = Field(default="", description="Zone (domain) where event occurred")


class DNSAnalytics(BaseModel):
    """DNS analytics summary from Cloudflare Gateway (Zero Trust).

    Aggregates query counts and blocked domains from Gateway DNS filtering.
    Only available with Zero Trust subscription.
    """

    total_queries: int = Field(default=0, description="Total DNS queries in period")
    blocked_queries: int = Field(default=0, description="Queries blocked by policy")
    allowed_queries: int = Field(default=0, description="Queries allowed through")
    top_blocked_domains: List[str] = Field(
        default_factory=list,
        description="Top domains that were blocked"
    )


class TunnelStatus(BaseModel):
    """Status of a Cloudflare Tunnel.

    Represents a cloudflared tunnel connecting internal resources.
    """

    name: str = Field(description="Tunnel name")
    tunnel_id: str = Field(description="Unique tunnel identifier")
    status: str = Field(description="Status: healthy, degraded, down, inactive")


class CloudflareData(BaseModel):
    """Aggregated Cloudflare data for report generation.

    Contains all data fetched from Cloudflare APIs, with sections
    that may be None if not available (e.g., DNS requires Gateway).
    """

    waf_events: List[WAFEvent] = Field(
        default_factory=list,
        description="WAF block events from all zones"
    )
    dns_analytics: Optional[DNSAnalytics] = Field(
        default=None,
        description="DNS analytics (None if Gateway not available)"
    )
    tunnels: List[TunnelStatus] = Field(
        default_factory=list,
        description="Tunnel statuses (empty if no tunnels)"
    )
    zones_queried: List[str] = Field(
        default_factory=list,
        description="Zone names that were queried for WAF events"
    )

    @property
    def has_waf_events(self) -> bool:
        """Check if any WAF events were recorded."""
        return len(self.waf_events) > 0

    @property
    def has_dns_analytics(self) -> bool:
        """Check if DNS analytics are available."""
        return self.dns_analytics is not None

    @property
    def has_tunnels(self) -> bool:
        """Check if any tunnels exist."""
        return len(self.tunnels) > 0

    @property
    def down_tunnels(self) -> List[TunnelStatus]:
        """Get tunnels that are down or degraded."""
        return [t for t in self.tunnels if t.status in ("down", "degraded")]

    def get_waf_by_source(self) -> Dict[str, List[WAFEvent]]:
        """Group WAF events by rule source.

        Returns:
            Dict mapping rule_source to list of events.
        """
        by_source: Dict[str, List[WAFEvent]] = {}
        for event in self.waf_events:
            if event.rule_source not in by_source:
                by_source[event.rule_source] = []
            by_source[event.rule_source].append(event)
        return by_source

    def get_top_blocked_ips(self, limit: int = 10) -> List[tuple[str, int]]:
        """Get top blocked IPs by event count.

        Args:
            limit: Maximum IPs to return.

        Returns:
            List of (ip, count) tuples sorted by count descending.
        """
        ip_counts: Dict[str, int] = {}
        for event in self.waf_events:
            ip_counts[event.source_ip] = ip_counts.get(event.source_ip, 0) + 1

        sorted_ips = sorted(ip_counts.items(), key=lambda x: x[1], reverse=True)
        return sorted_ips[:limit]
```
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/unifi_scanner && python -c "
from unifi_scanner.integrations.cloudflare.models import WAFEvent, DNSAnalytics, TunnelStatus, CloudflareData
from datetime import datetime

# Test WAFEvent
e = WAFEvent(timestamp=datetime.now(), action='block', source_ip='1.2.3.4', rule_source='waf')
print(f'WAFEvent: {e.source_ip}')

# Test CloudflareData
d = CloudflareData(waf_events=[e])
print(f'has_waf_events: {d.has_waf_events}')
print(f'top_blocked_ips: {d.get_top_blocked_ips()}')
"
```
  </verify>
  <done>
All models importable and validate correctly. CloudflareData helper methods work.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CloudflareClient with API methods</name>
  <files>
    src/unifi_scanner/integrations/cloudflare/client.py
    src/unifi_scanner/integrations/cloudflare/__init__.py
  </files>
  <action>
Create `client.py` with CloudflareClient class:

```python
"""Cloudflare API client for WAF events, DNS analytics, and tunnel status.

Uses httpx for GraphQL queries (WAF, DNS) and cloudflare SDK for REST (tunnels).
Per RESEARCH.md: SDK doesn't have GraphQL client, so direct httpx is simpler.
"""

from __future__ import annotations

from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

import httpx
import structlog
from cloudflare import Cloudflare

from unifi_scanner.integrations.cloudflare.models import (
    CloudflareData,
    DNSAnalytics,
    TunnelStatus,
    WAFEvent,
)

log = structlog.get_logger()

GRAPHQL_ENDPOINT = "https://api.cloudflare.com/client/v4/graphql"

# GraphQL query for WAF events (per RESEARCH.md)
FIREWALL_EVENTS_QUERY = """
query GetFirewallEvents($zoneTag: string!, $start: Time!, $end: Time!, $limit: Int!) {
    viewer {
        zones(filter: {zoneTag: $zoneTag}) {
            firewallEventsAdaptive(
                filter: {
                    datetime_geq: $start
                    datetime_leq: $end
                    action: "block"
                }
                limit: $limit
                orderBy: [datetime_DESC]
            ) {
                action
                clientCountryName
                clientIP
                clientRequestPath
                clientRequestHTTPHost
                datetime
                source
                ruleId
                userAgent
            }
        }
    }
}
"""

# GraphQL query for DNS analytics (Gateway/Zero Trust)
DNS_ANALYTICS_QUERY = """
query GetDNSAnalytics($accountTag: string!, $start: Time!, $end: Time!) {
    viewer {
        accounts(filter: {accountTag: $accountTag}) {
            gatewayResolverQueriesAdaptiveGroups(
                filter: {
                    datetime_geq: $start
                    datetime_leq: $end
                }
                limit: 10000
            ) {
                count
                dimensions {
                    resolverDecision
                    queryName
                }
            }
        }
    }
}
"""


class CloudflareClient:
    """Client for Cloudflare API access.

    Fetches WAF events via GraphQL, tunnel status via REST SDK,
    and DNS analytics via GraphQL (if Gateway available).

    Example::

        client = CloudflareClient(token="...", account_id="...")
        data = await client.fetch_all(lookback_hours=24)
    """

    def __init__(
        self,
        token: str,
        account_id: Optional[str] = None,
        timeout: float = 30.0,
    ) -> None:
        """Initialize client.

        Args:
            token: Cloudflare API token with required permissions.
            account_id: Account ID for tunnel/DNS APIs. Auto-discovered if not set.
            timeout: HTTP request timeout in seconds.
        """
        self._token = token
        self._account_id = account_id
        self._timeout = timeout
        self._sdk = Cloudflare(api_token=token)

    async def fetch_all(
        self,
        lookback_hours: int = 24,
        waf_limit: int = 100,
    ) -> CloudflareData:
        """Fetch all Cloudflare data for report.

        Collects WAF events from all zones, DNS analytics (if available),
        and tunnel status. Handles missing Gateway gracefully.

        Args:
            lookback_hours: Hours of history to fetch.
            waf_limit: Maximum WAF events per zone.

        Returns:
            CloudflareData with all available data.
        """
        # Discover zones first
        zones = await self._get_zones()
        if not zones:
            log.warning("cloudflare_no_zones", message="No zones found for API token")
            return CloudflareData()

        zone_names = [z["name"] for z in zones]

        # Discover account_id from first zone if not provided
        account_id = self._account_id
        if not account_id and zones:
            account_id = zones[0].get("account", {}).get("id")
            if account_id:
                log.debug("cloudflare_account_discovered", account_id=account_id)

        # Fetch WAF events from all zones
        waf_events: List[WAFEvent] = []
        for zone in zones:
            zone_events = await self._fetch_waf_events(
                zone["id"],
                zone["name"],
                lookback_hours,
                waf_limit,
            )
            waf_events.extend(zone_events)

        # Fetch DNS analytics (may be None if Gateway unavailable)
        dns_analytics = None
        if account_id:
            dns_analytics = await self._fetch_dns_analytics(account_id, lookback_hours)

        # Fetch tunnel status
        tunnels: List[TunnelStatus] = []
        if account_id:
            tunnels = await self._fetch_tunnels(account_id)

        return CloudflareData(
            waf_events=waf_events,
            dns_analytics=dns_analytics,
            tunnels=tunnels,
            zones_queried=zone_names,
        )

    async def _get_zones(self) -> List[Dict[str, Any]]:
        """Get all zones accessible by the API token."""
        try:
            zones = list(self._sdk.zones.list())
            return [
                {
                    "id": z.id,
                    "name": z.name,
                    "account": {"id": z.account.id} if z.account else {},
                }
                for z in zones
            ]
        except Exception as e:
            log.error("cloudflare_zones_error", error=str(e))
            return []

    async def _fetch_waf_events(
        self,
        zone_id: str,
        zone_name: str,
        lookback_hours: int,
        limit: int,
    ) -> List[WAFEvent]:
        """Fetch WAF block events for a zone via GraphQL."""
        now = datetime.now(timezone.utc)
        start = now - timedelta(hours=lookback_hours)

        try:
            async with httpx.AsyncClient(timeout=self._timeout) as client:
                response = await client.post(
                    GRAPHQL_ENDPOINT,
                    headers={
                        "Authorization": f"Bearer {self._token}",
                        "Content-Type": "application/json",
                    },
                    json={
                        "query": FIREWALL_EVENTS_QUERY,
                        "variables": {
                            "zoneTag": zone_id,
                            "start": start.isoformat(),
                            "end": now.isoformat(),
                            "limit": limit,
                        },
                    },
                )
                response.raise_for_status()
                data = response.json()

            if data.get("errors"):
                log.warning(
                    "cloudflare_waf_graphql_errors",
                    zone=zone_name,
                    errors=data["errors"],
                )
                return []

            # Parse events
            zones_data = data.get("data", {}).get("viewer", {}).get("zones", [])
            if not zones_data:
                return []

            raw_events = zones_data[0].get("firewallEventsAdaptive", [])

            events = []
            for e in raw_events:
                try:
                    events.append(WAFEvent(
                        timestamp=datetime.fromisoformat(e["datetime"].rstrip("Z")),
                        action=e["action"],
                        source_ip=e["clientIP"],
                        country=e.get("clientCountryName", ""),
                        path=e.get("clientRequestPath", ""),
                        host=e.get("clientRequestHTTPHost", ""),
                        rule_source=e["source"],
                        rule_id=e.get("ruleId"),
                        user_agent=e.get("userAgent", ""),
                        zone_name=zone_name,
                    ))
                except Exception as parse_err:
                    log.debug("cloudflare_waf_parse_error", error=str(parse_err))

            log.debug(
                "cloudflare_waf_fetched",
                zone=zone_name,
                events=len(events),
            )
            return events

        except Exception as e:
            log.error("cloudflare_waf_error", zone=zone_name, error=str(e))
            return []

    async def _fetch_dns_analytics(
        self,
        account_id: str,
        lookback_hours: int,
    ) -> Optional[DNSAnalytics]:
        """Fetch DNS analytics from Gateway (Zero Trust).

        Returns None if Gateway is not available for this account.
        """
        now = datetime.now(timezone.utc)
        start = now - timedelta(hours=lookback_hours)

        try:
            async with httpx.AsyncClient(timeout=self._timeout) as client:
                response = await client.post(
                    GRAPHQL_ENDPOINT,
                    headers={
                        "Authorization": f"Bearer {self._token}",
                        "Content-Type": "application/json",
                    },
                    json={
                        "query": DNS_ANALYTICS_QUERY,
                        "variables": {
                            "accountTag": account_id,
                            "start": start.isoformat(),
                            "end": now.isoformat(),
                        },
                    },
                )
                response.raise_for_status()
                data = response.json()

            if data.get("errors"):
                # Gateway not available - this is expected for many users
                log.debug(
                    "cloudflare_dns_not_available",
                    message="Gateway DNS analytics not available (requires Zero Trust)",
                )
                return None

            accounts = data.get("data", {}).get("viewer", {}).get("accounts", [])
            if not accounts:
                return None

            groups = accounts[0].get("gatewayResolverQueriesAdaptiveGroups", [])

            total = 0
            blocked = 0
            blocked_domains: List[str] = []

            for group in groups:
                count = group["count"]
                decision = group["dimensions"]["resolverDecision"]
                domain = group["dimensions"].get("queryName", "")

                total += count
                if decision in ("blocked", "blockedByCategory"):
                    blocked += count
                    if domain and domain not in blocked_domains:
                        blocked_domains.append(domain)

            log.debug(
                "cloudflare_dns_fetched",
                total=total,
                blocked=blocked,
            )

            return DNSAnalytics(
                total_queries=total,
                blocked_queries=blocked,
                allowed_queries=total - blocked,
                top_blocked_domains=blocked_domains[:10],  # Top 10
            )

        except Exception as e:
            log.debug("cloudflare_dns_error", error=str(e))
            return None

    async def _fetch_tunnels(self, account_id: str) -> List[TunnelStatus]:
        """Fetch tunnel status from Cloudflare.

        Returns empty list if no tunnels or API not available.
        Per CONTEXT.md: Skip tunnel section if no tunnels exist.
        """
        try:
            tunnels = list(self._sdk.zero_trust.tunnels.list(
                account_id=account_id,
                is_deleted=False,
            ))

            result = [
                TunnelStatus(
                    name=t.name,
                    tunnel_id=t.id,
                    status=t.status,
                )
                for t in tunnels
                if t.status != "inactive"  # Only show tunnels that have been run
            ]

            log.debug("cloudflare_tunnels_fetched", count=len(result))
            return result

        except Exception as e:
            log.debug("cloudflare_tunnels_error", error=str(e))
            return []
```

Update `__init__.py` to export the client and models:
```python
"""Cloudflare integration for WAF events, DNS analytics, and tunnel status."""

from unifi_scanner.integrations.cloudflare.client import CloudflareClient
from unifi_scanner.integrations.cloudflare.models import (
    CloudflareData,
    DNSAnalytics,
    TunnelStatus,
    WAFEvent,
)

__all__ = [
    "CloudflareClient",
    "CloudflareData",
    "DNSAnalytics",
    "TunnelStatus",
    "WAFEvent",
]
```
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/unifi_scanner && python -c "
from unifi_scanner.integrations.cloudflare import CloudflareClient, CloudflareData, WAFEvent
print('CloudflareClient imported successfully')
print('Ready for integration implementation')
"
```
  </verify>
  <done>
CloudflareClient importable with all methods. Models and client exports configured in __init__.py.
  </done>
</task>

</tasks>

<verification>
1. `pip install -e .` succeeds with cloudflare SDK
2. UnifiSettings has cloudflare_api_token and cloudflare_account_id fields
3. All models import and validate correctly
4. CloudflareClient imports without errors
5. `python -m pytest tests/ -x -q` passes (no regressions)
</verification>

<success_criteria>
- cloudflare>=4.3 in pyproject.toml dependencies
- Settings fields for Cloudflare credentials exist
- WAFEvent, DNSAnalytics, TunnelStatus, CloudflareData models work
- CloudflareClient has fetch_all, _fetch_waf_events, _fetch_dns_analytics, _fetch_tunnels methods
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-cloudflare-integration/11-01-SUMMARY.md`
</output>
